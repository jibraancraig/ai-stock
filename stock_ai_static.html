<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Machine Learning AI Investor</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap");

      * {
        font-family: "Montserrat", sans-serif;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(
          135deg,
          #0f0f0f 0%,
          #1a0f0f 25%,
          #2d1b1b 50%,
          #3d2b2b 75%,
          #4d3b3b 100%
        );
        color: #ffffff;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        background: transparent;
        padding: 0;
        max-width: 1400px;
        margin: 0 auto;
      }

      /* Header Styling */
      .header-container {
        text-align: center;
        padding: 2rem 0 1rem 0;
        position: relative;
      }

      .main-title {
        font-size: 2.5rem;
        font-weight: 700;
        color: #8b0000;
        margin-bottom: 0.5rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .creator-signature {
        position: absolute;
        top: 1rem;
        right: 2rem;
        font-size: 0.875rem;
        color: rgba(255, 255, 255, 0.7);
        font-weight: 400;
      }

      /* Search Section */
      .search-section {
        background: rgba(45, 27, 27, 0.8);
        border: 1px solid rgba(139, 0, 0, 0.4);
        border-radius: 15px;
        padding: 1.5rem;
        margin: 0 2rem 2rem 2rem;
        box-shadow: 0 8px 32px rgba(139, 0, 0, 0.2);
        backdrop-filter: blur(10px);
      }

      .search-title {
        color: #8b0000;
        font-weight: 600;
        font-size: 1.25rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .search-input-group {
        display: flex;
        gap: 1rem;
        align-items: center;
      }

      .search-input {
        flex: 1;
        background: rgba(45, 27, 27, 0.9);
        border: 1px solid rgba(139, 0, 0, 0.5);
        border-radius: 10px;
        color: #ffffff;
        font-weight: 400;
        padding: 0.75rem 1rem;
        font-size: 1rem;
      }

      .search-input:focus {
        outline: none;
        border-color: #8b0000;
        box-shadow: 0 0 0 2px rgba(139, 0, 0, 0.25);
      }

      .search-input::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .analyze-btn {
        background: #8b0000;
        border: none;
        border-radius: 10px;
        color: #ffffff;
        font-weight: 500;
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        white-space: nowrap;
      }

      .analyze-btn:hover {
        background: #a00000;
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(139, 0, 0, 0.4);
      }

      .analyze-btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      /* Filter Section */
      .filter-section {
        margin-top: 1.5rem;
        padding-top: 1.5rem;
        border-top: 1px solid rgba(139, 0, 0, 0.3);
      }

      .filter-title {
        color: #8b0000;
        font-weight: 600;
        font-size: 1rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .filter-buttons {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .filter-btn {
        background: rgba(45, 27, 27, 0.9);
        border: 1px solid rgba(139, 0, 0, 0.5);
        border-radius: 8px;
        color: #ffffff;
        font-weight: 500;
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .filter-btn:hover {
        background: rgba(139, 0, 0, 0.3);
        border-color: #8b0000;
      }

      .filter-btn-active {
        background: #8b0000;
        border-color: #8b0000;
        box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3);
      }

      .filter-btn-active:hover {
        background: #a00000;
      }

      /* Stock List Section */
      .stock-list-section {
        background: rgba(45, 27, 27, 0.9);
        border: 1px solid rgba(139, 0, 0, 0.3);
        border-radius: 15px;
        padding: 1.5rem;
        margin: 0 2rem 2rem 2rem;
        box-shadow: 0 8px 32px rgba(139, 0, 0, 0.2);
        backdrop-filter: blur(10px);
      }

      .stock-list-title {
        color: #8b0000;
        font-weight: 600;
        font-size: 1.25rem;
        margin-bottom: 1.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .stock-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 1rem;
      }

      .stock-item {
        background: rgba(45, 27, 27, 0.8);
        border: 1px solid rgba(139, 0, 0, 0.3);
        border-radius: 10px;
        padding: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .stock-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(139, 0, 0, 0.3);
        border-color: #8b0000;
      }

      .stock-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
      }

      .stock-symbol {
        font-weight: 700;
        font-size: 1.125rem;
        color: #ffffff;
      }

      .stock-recommendation {
        padding: 0.25rem 0.75rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.875rem;
      }

      .recommendation-buy {
        background: rgba(40, 167, 69, 0.2);
        color: #4ade80;
        border: 1px solid #4ade80;
      }

      .recommendation-hold {
        background: rgba(255, 193, 7, 0.2);
        color: #fbbf24;
        border: 1px solid #fbbf24;
      }

      .recommendation-sell {
        background: rgba(220, 53, 69, 0.2);
        color: #f87171;
        border: 1px solid #f87171;
      }

      .stock-details {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
        font-size: 0.875rem;
      }

      .stock-detail {
        color: #ffffff;
      }

      .stock-detail-label {
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.75rem;
      }

      /* Cards Grid */
      .cards-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
        padding: 0 2rem 2rem 2rem;
        max-width: 1400px;
        margin: 0 auto;
      }

      .card {
        background: rgba(45, 27, 27, 0.9);
        border: 1px solid rgba(139, 0, 0, 0.3);
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(139, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        min-height: 300px;
        display: flex;
        flex-direction: column;
      }

      .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(139, 0, 0, 0.3);
      }

      .card-header {
        padding: 1.5rem 1.5rem 1rem 1.5rem;
        border-bottom: 1px solid rgba(139, 0, 0, 0.2);
      }

      .card-title {
        color: #8b0000;
        font-weight: 600;
        font-size: 1.25rem;
        margin: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .card-body {
        padding: 1.5rem;
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .card-content {
        flex: 1;
      }

      /* Typography */
      .bold-number {
        font-weight: 700;
        color: #8b0000;
      }

      .bold-text {
        font-weight: 600;
        color: #ffffff;
      }

      .regular-text {
        color: #ffffff;
        font-weight: 400;
        margin-bottom: 0.75rem;
      }

      /* Alert Styling */
      .alert {
        border-radius: 10px;
        border: none;
        font-weight: 500;
        padding: 1rem;
        margin-bottom: 1rem;
      }

      .alert-success {
        background: rgba(40, 167, 69, 0.2);
        color: #4ade80;
        border-left: 4px solid #4ade80;
      }

      .alert-danger {
        background: rgba(220, 53, 69, 0.2);
        color: #f87171;
        border-left: 4px solid #f87171;
      }

      .alert-warning {
        background: rgba(255, 193, 7, 0.2);
        color: #fbbf24;
        border-left: 4px solid #fbbf24;
      }

      /* List Styling */
      ul {
        list-style: none;
        padding-left: 0;
      }

      li {
        color: #ffffff;
        margin-bottom: 0.5rem;
        padding-left: 1rem;
        position: relative;
      }

      li:before {
        content: "‚Ä¢";
        color: #8b0000;
        font-weight: bold;
        position: absolute;
        left: 0;
      }

      /* Chart Container */
      .chart-container {
        background: rgba(45, 27, 27, 0.9);
        border: 1px solid rgba(139, 0, 0, 0.3);
        border-radius: 15px;
        padding: 1.5rem;
        margin: 0 2rem 2rem 2rem;
        box-shadow: 0 8px 32px rgba(139, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        height: 500px;
        position: relative;
      }

      .chart-wrapper {
        height: 400px;
        width: 100%;
        position: relative;
      }

      .chart-title {
        color: #8b0000;
        font-weight: 600;
        font-size: 1.25rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      /* Loading Animation */
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(139, 0, 0, 0.3);
        border-radius: 50%;
        border-top-color: #8b0000;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loading-container {
        text-align: center;
        color: #ff6b6b;
        padding: 2rem;
      }

      /* Error Styling */
      .error-message {
        background: rgba(220, 53, 69, 0.2);
        color: #f87171;
        border-left: 4px solid #f87171;
        padding: 1rem;
        border-radius: 10px;
        margin: 1rem 0;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .cards-grid {
          grid-template-columns: 1fr;
          gap: 1.5rem;
          padding: 0 1rem 1rem 1rem;
        }

        .search-section {
          margin: 0 1rem 1.5rem 1rem;
        }

        .search-input-group {
          flex-direction: column;
          gap: 0.75rem;
        }

        .main-title {
          font-size: 2rem;
        }

        .creator-signature {
          position: static;
          text-align: center;
          margin-top: 0.5rem;
        }

        /* Advanced Analysis Styles */
        .pattern-section,
        .elliott-section,
        .harmonic-section,
        .volume-profile-section,
        .order-flow-section,
        .timeframe-section,
        .fundamental-section {
          margin: 1rem 0;
          padding: 1rem;
          background: rgba(45, 27, 27, 0.7);
          border-radius: 10px;
          border: 1px solid rgba(139, 0, 0, 0.3);
        }

        .pattern-item,
        .wave-item,
        .harmonic-item,
        .timeframe-item {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 0.5rem;
          margin: 0.25rem 0;
          background: rgba(139, 0, 0, 0.2);
          border-radius: 5px;
          border-left: 3px solid #8b0000;
        }

        .pattern-name,
        .wave-number,
        .harmonic-name,
        .timeframe-label {
          font-weight: bold;
          color: #ffd700;
        }

        .pattern-confidence,
        .harmonic-confidence {
          color: #00ff00;
          font-weight: bold;
        }

        .pattern-signal {
          padding: 0.2rem 0.5rem;
          border-radius: 3px;
          font-size: 0.8rem;
          font-weight: bold;
        }

        .badge-success {
          background: rgba(0, 255, 0, 0.2);
          color: #00ff00;
          border: 1px solid #00ff00;
        }

        .badge-danger {
          background: rgba(255, 0, 0, 0.2);
          color: #ff0000;
          border: 1px solid #ff0000;
        }

        .badge-warning {
          background: rgba(255, 165, 0, 0.2);
          color: #ffa500;
          border: 1px solid #ffa500;
        }

        .pattern-category {
          font-size: 0.8rem;
          color: #ccc;
          font-style: italic;
        }

        .wave-direction {
          font-size: 1.2rem;
        }

        .wave-length,
        .wave-range {
          font-size: 0.9rem;
          color: #ccc;
        }

        .timeframe-trend {
          font-size: 1.2rem;
        }

        .timeframe-price {
          font-weight: bold;
          color: #ffd700;
        }

        #advanced-analysis h3 {
          color: #ffd700;
          border-bottom: 2px solid #8b0000;
          padding-bottom: 0.5rem;
          margin-bottom: 1rem;
        }

        #advanced-analysis p {
          margin: 0.5rem 0;
          color: #ccc;
        }

        #advanced-analysis strong {
          color: #ffd700;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header-container">
        <h1 class="main-title">üìà Machine Learning AI Investor</h1>
        <div class="creator-signature">Made by Jibraan Craig</div>
      </div>

      <!-- Search Section -->
      <div class="search-section">
        <h5 class="search-title">üîç Stock Analysis</h5>
        <div class="search-input-group">
          <input
            type="text"
            id="symbol-input"
            class="search-input"
            placeholder="Please search any stock symbol (e.g AAPL)"
            value="AAPL"
          />
          <button id="analyze-btn" class="analyze-btn">Analyse</button>
        </div>

        <!-- Filter Section -->
        <div class="filter-section">
          <h6 class="filter-title">üéØ Filter by Recommendation</h6>
          <div class="filter-buttons">
            <button id="filter-all" class="filter-btn filter-btn-active">
              All
            </button>
            <button id="filter-buy" class="filter-btn">BUY</button>
            <button id="filter-hold" class="filter-btn">HOLD</button>
            <button id="filter-sell" class="filter-btn">SELL</button>
          </div>
        </div>
      </div>

      <!-- Loading Output -->
      <div id="loading-output"></div>

      <!-- Stock List Section -->
      <div
        id="stock-list-section"
        class="stock-list-section"
        style="display: none"
      >
        <h5 class="stock-list-title">üìà Stock Recommendations</h5>
        <div id="stock-list" class="stock-list">
          <!-- Stock items will be populated here -->
        </div>
      </div>

      <!-- Chart Container -->
      <div id="chart-container" class="chart-container" style="display: none">
        <h5 class="chart-title">üìä Price Chart</h5>
        <div class="chart-wrapper">
          <canvas id="price-chart"></canvas>
        </div>
      </div>

      <!-- Cards Grid -->
      <div class="cards-grid">
        <!-- Top Left Card - Stock Info -->
        <div class="card">
          <div class="card-header">
            <h5 id="stock-title" class="card-title">üìä AAPL - Apple Inc.</h5>
          </div>
          <div id="stock-info-card" class="card-body">
            <div class="card-content">
              <p class="regular-text">
                üí∞ Current Price: <span class="bold-number">$0.00</span>
              </p>
              <p class="regular-text">
                üìà Market Cap: <span class="bold-number">$0</span>
              </p>
              <p class="regular-text">
                üè¢ Sector: <span class="bold-text">N/A</span>
              </p>
              <p class="regular-text">
                üìÖ Data Points: <span class="bold-number">0 days</span>
              </p>
              <p class="regular-text">
                üìä Volume: <span class="bold-number">0</span>
              </p>
            </div>
          </div>
        </div>

        <!-- Top Right Card - Trading Recommendation -->
        <div class="card">
          <div class="card-header">
            <h5 class="card-title">üéØ Trading Recommendation</h5>
          </div>
          <div id="recommendation-card" class="card-body">
            <div class="card-content">
              <div class="alert alert-warning">HOLD - Confidence: 0%</div>
              <h6
                class="bold-text"
                style="margin-top: 1rem; margin-bottom: 0.5rem"
              >
                Key Signals:
              </h6>
              <ul>
                <li>Enter a stock symbol to get analysis</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Bottom Left Card - Technical Analysis -->
        <div class="card">
          <div class="card-header">
            <h5 class="card-title">üìà Technical Analysis</h5>
          </div>
          <div id="technical-content" class="card-body">
            <div class="card-content">
              <p class="regular-text">
                RSI: <span class="bold-number">0.0</span>
              </p>
              <p class="regular-text">
                Price Change (20d): <span class="bold-number">0.0%</span>
              </p>
              <p class="regular-text">
                Volume Ratio: <span class="bold-number">0.0x average</span>
              </p>
              <p class="regular-text">
                MACD: <span class="bold-number">0.000</span>
              </p>
              <p class="regular-text">
                Data Quality: <span class="bold-text">No data</span>
              </p>
            </div>
          </div>
        </div>

        <!-- Bottom Right Card - Risk Assessment -->
        <div class="card">
          <div class="card-header">
            <h5 class="card-title">‚ö†Ô∏è Risk Assessment</h5>
          </div>
          <div id="risk-content" class="card-body">
            <div class="card-content">
              <div class="alert alert-warning">Risk Level: Unknown</div>
              <p class="regular-text">
                Volatility: <span class="bold-number">0.0%</span>
              </p>
              <p class="regular-text">
                Max Drawdown: <span class="bold-number">0.0%</span>
              </p>
              <p class="regular-text">
                Sharpe Ratio: <span class="bold-number">0.00</span>
              </p>
              <p class="regular-text">
                Beta: <span class="bold-text">N/A</span>
              </p>
            </div>
          </div>
        </div>
      </div>

      <div class="analysis-section">
        <h3>üìä Technical Analysis</h3>
        <div id="technical-analysis"></div>
      </div>

      <div class="analysis-section">
        <h3>ü§ñ Advanced Analysis</h3>
        <div id="advanced-analysis"></div>
      </div>
    </div>

    <script>
      // Global variables
      let currentChart = null
      let stockData = null
      let allStocksData = [] // Store all analyzed stocks
      let currentFilter = "all" // Current filter state
      let symbolInput,
        analyzeBtn,
        loadingOutput,
        stockTitle,
        stockInfoCard,
        recommendationCard,
        technicalContent,
        riskContent,
        chartContainer,
        priceChart
      let filterAll,
        filterBuy,
        filterHold,
        filterSell,
        stockListSection,
        stockList

      // Initialize DOM elements and event listeners
      document.addEventListener("DOMContentLoaded", function () {
        // DOM elements
        symbolInput = document.getElementById("symbol-input")
        analyzeBtn = document.getElementById("analyze-btn")
        loadingOutput = document.getElementById("loading-output")
        stockTitle = document.getElementById("stock-title")
        stockInfoCard = document.getElementById("stock-info-card")
        recommendationCard = document.getElementById("recommendation-card")
        technicalContent = document.getElementById("technical-content")
        riskContent = document.getElementById("risk-content")
        chartContainer = document.getElementById("chart-container")
        priceChart = document.getElementById("price-chart")

        // Filter elements
        filterAll = document.getElementById("filter-all")
        filterBuy = document.getElementById("filter-buy")
        filterHold = document.getElementById("filter-hold")
        filterSell = document.getElementById("filter-sell")
        stockListSection = document.getElementById("stock-list-section")
        stockList = document.getElementById("stock-list")

        // Check if all elements exist
        if (!symbolInput || !analyzeBtn) {
          console.error("Required DOM elements not found")
          return
        }

        // Event listeners
        analyzeBtn.addEventListener("click", analyzeStock)
        symbolInput.addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            analyzeStock()
          }
        })

        // Filter event listeners
        if (filterAll)
          filterAll.addEventListener("click", () => setFilter("all"))
        if (filterBuy)
          filterBuy.addEventListener("click", () => setFilter("buy"))
        if (filterHold)
          filterHold.addEventListener("click", () => setFilter("hold"))
        if (filterSell)
          filterSell.addEventListener("click", () => setFilter("sell"))

        // Auto-analyze AAPL on page load
        setTimeout(() => {
          if (symbolInput) {
            symbolInput.value = "AAPL"
            analyzeStock()
          }
        }, 1000)
      })

      // Main analysis function
      async function analyzeStock() {
        if (!symbolInput || !symbolInput.value.trim()) {
          showError("Please enter a stock symbol")
          return
        }

        const symbol = symbolInput.value.trim().toUpperCase()
        console.log("Starting analysis for:", symbol)

        try {
          showLoading(true)

          // Fetch comprehensive data
          console.log("Fetching stock data...")
          const stockData = await fetchStockData(symbol)
          console.log(
            "Stock data received:",
            stockData ? stockData.length : 0,
            "data points"
          )

          console.log("Fetching fundamental data...")
          const fundamentalData = await fetchFundamentalData(symbol)
          console.log(
            "Fundamental data received:",
            fundamentalData ? "yes" : "no"
          )

          console.log("Fetching multi-timeframe data...")
          const multiTimeframeData = await fetchMultiTimeframeData(symbol)
          console.log(
            "Multi-timeframe data received:",
            multiTimeframeData ? Object.keys(multiTimeframeData).length : 0,
            "timeframes"
          )

          if (!stockData || stockData.length < 50) {
            throw new Error("Insufficient data for analysis")
          }

          // Calculate all technical indicators
          const technicalIndicators = calculateAdvancedIndicators(stockData)

          // AI Pattern Recognition
          const aiPatterns = patternAI.detectPatterns(stockData)

          // Advanced Analysis
          const fibonacci = calculateFibonacciRetracements(stockData)
          const elliottWaves = analyzeElliottWaves(stockData)
          const harmonicPatterns = detectHarmonicPatterns(stockData)
          const volumeProfile = calculateVolumeProfile(stockData)
          const orderFlow = analyzeOrderFlow(stockData)

          // Enhanced recommendation generation
          const recommendation = generateAdvancedRecommendation(
            stockData,
            technicalIndicators,
            aiPatterns,
            fundamentalData
          )

          // Update UI with comprehensive analysis
          console.log("Updating UI...")
          try {
            updateStockInfo(symbol, stockData)
            updateChart(stockData, technicalIndicators, fibonacci, aiPatterns)
            updateRecommendation(recommendation)
            updateTechnicalAnalysis(technicalIndicators)
            updateAdvancedAnalysis({
              aiPatterns,
              elliottWaves,
              harmonicPatterns,
              volumeProfile,
              orderFlow,
              multiTimeframeData,
              fundamentalData,
            })
            updateStockTitle(symbol)
            console.log("UI updated successfully")
          } catch (uiError) {
            console.error("UI update failed:", uiError)
          }

          // Store for filtering
          const stockAnalysis = {
            symbol: symbolInput.value.trim().toUpperCase(),
            data: stockData,
            recommendation: recommendation.recommendation,
            confidence: recommendation.confidence,
            price: stockData[stockData.length - 1].close,
            priceChange: recommendation.price_change,
            rsi: recommendation.rsi,
            volumeRatio: recommendation.volume_ratio,
            fundamentalData: fundamentalData,
            technicalIndicators: technicalIndicators,
            aiPatterns: aiPatterns,
            score: recommendation.confidence,
          }

          // Add to global stock list
          const existingIndex = allStocksData.findIndex(
            (s) => s.symbol === symbolInput.value.trim().toUpperCase()
          )
          if (existingIndex >= 0) {
            allStocksData[existingIndex] = stockAnalysis
          } else {
            allStocksData.push(stockAnalysis)
          }

          updateStockList()
        } catch (error) {
          console.error("Analysis failed:", error)
          showError(`Analysis failed: ${error.message}`)
        } finally {
          showLoading(false)
        }
      }

      // Enhanced recommendation generation
      function generateAdvancedRecommendation(
        data,
        indicators,
        aiPatterns,
        fundamentalData
      ) {
        if (data.length < 20) {
          return {
            recommendation: "HOLD",
            confidence: 0,
            signals: ["Insufficient data"],
            color: "warning",
            price_change: 0,
            rsi: 50,
            volume_ratio: 1,
          }
        }

        const latest = data[data.length - 1]
        const prev20 = data[Math.max(0, data.length - 21)]
        const priceChange = ((latest.close - prev20.close) / prev20.close) * 100

        let confidence = 0
        const signals = []

        // Technical Analysis Signals (40% weight)
        const technicalScore = calculateTechnicalScore(indicators, data)
        confidence += technicalScore.score * 0.4
        signals.push(...technicalScore.signals)

        // AI Pattern Recognition (30% weight)
        const patternScore = calculatePatternScore(aiPatterns)
        confidence += patternScore.score * 0.3
        signals.push(...patternScore.signals)

        // Fundamental Analysis (20% weight)
        const fundamentalScore = calculateFundamentalScore(fundamentalData)
        confidence += fundamentalScore.score * 0.2
        signals.push(...fundamentalScore.signals)

        // Volume Analysis (10% weight)
        const volumeScore = calculateVolumeScore(data, indicators)
        confidence += volumeScore.score * 0.1
        signals.push(...volumeScore.signals)

        // Determine recommendation
        let recommendation, color
        if (confidence > 25) {
          recommendation = "BUY"
          color = "success"
        } else if (confidence < -25) {
          recommendation = "SELL"
          color = "danger"
        } else {
          recommendation = "HOLD"
          color = "warning"
        }

        return {
          recommendation,
          confidence: Math.abs(confidence),
          signals,
          color,
          price_change: priceChange,
          rsi: indicators.rsi,
          volume_ratio: indicators.obv > 0 ? 1.2 : 0.8,
        }
      }

      function calculateTechnicalScore(indicators, data) {
        let score = 0
        const signals = []

        // RSI signals
        if (indicators.rsi < 30) {
          score += 15
          signals.push("RSI oversold")
        } else if (indicators.rsi > 70) {
          score -= 15
          signals.push("RSI overbought")
        }

        // MACD signals
        if (indicators.macd > 0) {
          score += 10
          signals.push("MACD bullish")
        } else {
          score -= 10
          signals.push("MACD bearish")
        }

        // Moving Average alignment
        if (
          indicators.ma20 > indicators.ma50 &&
          indicators.ma50 > indicators.ma200
        ) {
          score += 15
          signals.push("Bullish MA alignment")
        } else if (
          indicators.ma20 < indicators.ma50 &&
          indicators.ma50 < indicators.ma200
        ) {
          score -= 15
          signals.push("Bearish MA alignment")
        }

        // Bollinger Bands
        const currentPrice = data[data.length - 1].close
        if (currentPrice < indicators.bb.lower) {
          score += 10
          signals.push("Price below BB lower band")
        } else if (currentPrice > indicators.bb.upper) {
          score -= 10
          signals.push("Price above BB upper band")
        }

        // ADX trend strength
        if (indicators.adx > 25) {
          score += 5
          signals.push("Strong trend")
        }

        return { score, signals }
      }

      function calculatePatternScore(aiPatterns) {
        let score = 0
        const signals = []

        if (aiPatterns && aiPatterns.length > 0) {
          const topPattern = aiPatterns[0]

          if (topPattern.signal === "BUY") {
            score += topPattern.score * 0.5
            signals.push(
              `${topPattern.pattern} (${topPattern.confidence.toFixed(
                1
              )}% confidence)`
            )
          } else if (topPattern.signal === "SELL") {
            score -= topPattern.score * 0.5
            signals.push(
              `${topPattern.pattern} (${topPattern.confidence.toFixed(
                1
              )}% confidence)`
            )
          }
        }

        return { score, signals }
      }

      function calculateFundamentalScore(fundamentalData) {
        let score = 0
        const signals = []

        if (!fundamentalData) return { score, signals }

        // P/E ratio analysis
        if (fundamentalData.peRatio > 0 && fundamentalData.peRatio < 15) {
          score += 10
          signals.push("Low P/E ratio")
        } else if (fundamentalData.peRatio > 25) {
          score -= 10
          signals.push("High P/E ratio")
        }

        // Growth metrics
        if (fundamentalData.revenueGrowth > 0.1) {
          score += 10
          signals.push("Strong revenue growth")
        }

        if (fundamentalData.earningsGrowth > 0.1) {
          score += 10
          signals.push("Strong earnings growth")
        }

        // Debt analysis
        if (fundamentalData.debtToEquity < 0.5) {
          score += 5
          signals.push("Low debt")
        } else if (fundamentalData.debtToEquity > 1) {
          score -= 5
          signals.push("High debt")
        }

        return { score, signals }
      }

      function calculateVolumeScore(data, indicators) {
        let score = 0
        const signals = []

        // Volume trend
        if (indicators.obv > 0) {
          score += 5
          signals.push("Positive volume trend")
        } else {
          score -= 5
          signals.push("Negative volume trend")
        }

        // Money Flow Index
        if (indicators.mfi < 20) {
          score += 10
          signals.push("Oversold (MFI)")
        } else if (indicators.mfi > 80) {
          score -= 10
          signals.push("Overbought (MFI)")
        }

        return { score, signals }
      }

      // Simple and reliable data fetching with realistic mock data
      async function fetchStockData(symbol) {
        console.log(`Fetching data for ${symbol}...`)

        // Use realistic mock data for reliable operation
        const mockData = generateRealisticMockData(symbol)
        console.log(`Generated ${mockData.length} data points for ${symbol}`)
        return mockData

        const apis = [
          // Primary: Yahoo Finance with CORS proxy
          async () => {
            try {
              console.log("Trying Yahoo Finance API with CORS proxy...")

              // Use CORS proxy to bypass restrictions
              const corsProxy = "https://cors-anywhere.herokuapp.com/"
              const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1y`

              const response = await fetch(corsProxy + yahooUrl, {
                headers: {
                  Origin: "https://stockai-ten.vercel.app",
                  "X-Requested-With": "XMLHttpRequest",
                },
              })

              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                )
              }

              const data = await response.json()
              console.log(
                "Yahoo Finance response received:",
                data ? "success" : "failed"
              )

              if (data.chart?.result?.[0]) {
                const result = data.chart.result[0]
                const timestamps = result.timestamp
                const quotes = result.indicators.quote[0]

                const stockData = []
                for (let i = 0; i < timestamps.length; i++) {
                  if (quotes.close[i] !== null) {
                    const date = new Date(timestamps[i] * 1000)
                    stockData.push({
                      date: date.toISOString().split("T")[0],
                      open: quotes.open[i] || quotes.close[i],
                      high: quotes.high[i] || quotes.close[i],
                      low: quotes.low[i] || quotes.close[i],
                      close: quotes.close[i],
                      volume: quotes.volume[i] || 1000000,
                    })
                  }
                }

                console.log(
                  `Yahoo Finance: ${stockData.length} data points received`
                )
                return stockData.length > 50 ? stockData : null
              }
              return null
            } catch (error) {
              console.error("Yahoo Finance API failed:", error.message)
              return null
            }
          },

          // Secondary: Alternative free API (no CORS issues)
          async () => {
            try {
              console.log("Trying alternative API...")
              // Using a free stock API that doesn't have CORS restrictions
              const response = await fetch(
                `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=1day&apikey=demo`
              )

              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                )
              }

              const data = await response.json()
              console.log(
                "Alternative API response received:",
                data ? "success" : "failed"
              )

              if (data.values && data.values.length > 0) {
                const stockData = data.values.map((item) => ({
                  date: item.datetime,
                  open: parseFloat(item.open),
                  high: parseFloat(item.high),
                  low: parseFloat(item.low),
                  close: parseFloat(item.close),
                  volume: parseInt(item.volume) || 1000000,
                }))

                console.log(
                  `Alternative API: ${stockData.length} data points received`
                )
                return stockData.length > 50 ? stockData : null
              }
              return null
            } catch (error) {
              console.error("Alternative API failed:", error.message)
              return null
            }
          },

          // Tertiary: IEX Cloud (if you have API key)
          async () => {
            // Uncomment and add your API key
            // const API_KEY = 'YOUR_IEX_CLOUD_KEY'
            // const response = await fetch(`https://cloud.iexapis.com/stable/stock/${symbol}/chart/1y?token=${API_KEY}`)
            // const data = await response.json()
            // Process IEX data...
            return null
          },
        ]

        // Try each API in sequence
        for (const api of apis) {
          try {
            const data = await api()
            if (data && data.length > 50) {
              console.log(
                `Successfully fetched real data for ${symbol} from ${api.name}`
              )
              return data
            }
          } catch (error) {
            console.log(`API failed for ${symbol}:`, error.message)
            continue
          }
        }

        // If all APIs fail, use mock data as fallback
        console.log("All APIs failed, using mock data as fallback...")
        return generateRealisticMockData(symbol)
      }

      // Generate realistic fundamental data
      async function fetchFundamentalData(symbol) {
        console.log("Generating fundamental data...")

        // Generate realistic fundamental data based on symbol
        const fundamentalData = generateFundamentalData(symbol)
        console.log("Fundamental data generated successfully")
      }

      // Generate realistic mock data based on actual market trends
      function generateRealisticMockData(symbol) {
        const days = 180
        const data = []

        // Realistic base prices (as of recent market data)
        const basePrices = {
          AAPL: 175,
          MSFT: 350,
          GOOGL: 140,
          AMZN: 180,
          TSLA: 250,
          NVDA: 800,
          META: 300,
          NFLX: 600,
        }

        let basePrice = basePrices[symbol] || 150 + Math.random() * 100

        // Realistic market trends (monthly returns)
        const monthlyTrends = {
          AAPL: 0.02, // ~2% monthly growth
          MSFT: 0.03, // ~3% monthly growth
          GOOGL: -0.01, // ~-1% monthly decline
          AMZN: 0.04, // ~4% monthly growth
          TSLA: -0.03, // ~-3% monthly decline
          NVDA: 0.05, // ~5% monthly growth
          META: 0.02, // ~2% monthly growth
          NFLX: -0.02, // ~-2% monthly decline
        }

        const monthlyTrend = monthlyTrends[symbol] || 0
        const dailyTrend = monthlyTrend / 30 // Convert to daily trend

        for (let i = 0; i < days; i++) {
          const date = new Date()
          date.setDate(date.getDate() - (days - i))

          // Realistic daily volatility (1-3% daily movement)
          const dailyVolatility = 0.015 + Math.random() * 0.01
          const randomChange = (Math.random() - 0.5) * dailyVolatility

          // Add trend component (much smaller)
          const trendChange = dailyTrend

          // Combine trend and random movement
          const totalChange = trendChange + randomChange
          basePrice *= 1 + totalChange

          // Ensure price stays within realistic bounds
          if (basePrice < 10) basePrice = 10
          if (basePrice > 2000) basePrice = 2000

          // Realistic OHLC data
          const dailyRange = basePrice * (0.005 + Math.random() * 0.01) // 0.5-1.5% daily range
          const open = basePrice * (1 + (Math.random() - 0.5) * 0.003)
          const close = basePrice
          const high = Math.max(open, close) + Math.random() * dailyRange
          const low = Math.min(open, close) - Math.random() * dailyRange

          // Realistic volume (varies by stock)
          const baseVolume =
            {
              AAPL: 50000000,
              MSFT: 30000000,
              GOOGL: 25000000,
              AMZN: 40000000,
              TSLA: 80000000,
              NVDA: 60000000,
              META: 35000000,
              NFLX: 20000000,
            }[symbol] || 30000000

          const volume = baseVolume * (0.5 + Math.random() * 1.0)

          data.push({
            date: date.toISOString().split("T")[0],
            open: open,
            high: high,
            low: low,
            close: close,
            volume: volume,
          })
        }

        return data
      }

      // Generate recommendation function
      function generateRecommendation(data) {
        if (data.length < 20) {
          return {
            recommendation: "HOLD",
            confidence: 0,
            signals: ["Insufficient data for analysis"],
            color: "warning",
            price_change: 0,
            rsi: 50,
            volume_ratio: 1,
          }
        }

        const latest = data[data.length - 1]
        const prev20 = data[Math.max(0, data.length - 21)]

        // Price trend
        const priceChange = ((latest.close - prev20.close) / prev20.close) * 100

        // RSI analysis
        const rsi = calculateRSI(data)

        // MACD analysis
        const macd = calculateMACD(data)

        // Volume analysis
        const avgVolume =
          data.reduce((sum, d) => sum + d.volume, 0) / data.length
        const currentVolume = latest.volume
        const volumeRatio = currentVolume / avgVolume

        // Generate recommendation
        let confidence = 0
        const signals = []

        if (priceChange > 5) {
          signals.push(`Strong uptrend (+${priceChange.toFixed(1)}%)`)
          confidence += 25
        } else if (priceChange > 0) {
          signals.push(`Slight uptrend (+${priceChange.toFixed(1)}%)`)
          confidence += 15
        } else if (priceChange < -5) {
          signals.push(`Strong downtrend (${priceChange.toFixed(1)}%)`)
          confidence -= 25
        } else {
          signals.push(`Sideways movement (${priceChange.toFixed(1)}%)`)
          confidence += 5
        }

        if (rsi < 30) {
          signals.push(`Oversold (RSI: ${rsi.toFixed(1)})`)
          confidence += 20
        } else if (rsi > 70) {
          signals.push(`Overbought (RSI: ${rsi.toFixed(1)})`)
          confidence -= 20
        }

        if (macd > 0) {
          signals.push("MACD bullish")
          confidence += 15
        } else {
          signals.push("MACD bearish")
          confidence -= 15
        }

        if (volumeRatio > 1.5) {
          signals.push(`High volume (${volumeRatio.toFixed(1)}x average)`)
          confidence += 10
        }

        // Determine recommendation
        let recommendation, color
        if (confidence > 20) {
          recommendation = "BUY"
          color = "success"
        } else if (confidence < -20) {
          recommendation = "SELL"
          color = "danger"
        } else {
          recommendation = "HOLD"
          color = "warning"
        }

        return {
          recommendation: recommendation,
          confidence: Math.abs(confidence),
          signals: signals,
          color: color,
          price_change: priceChange,
          rsi: rsi,
          volume_ratio: volumeRatio,
        }
      }

      // Generate realistic fundamental data
      function generateFundamentalData(symbol) {
        const baseData = {
          AAPL: {
            peRatio: 28.5,
            marketCap: 2.8e12,
            revenueGrowth: 0.08,
            debtToEquity: 1.2,
          },
          MSFT: {
            peRatio: 32.1,
            marketCap: 2.9e12,
            revenueGrowth: 0.12,
            debtToEquity: 0.8,
          },
          GOOGL: {
            peRatio: 25.8,
            marketCap: 1.8e12,
            revenueGrowth: 0.15,
            debtToEquity: 0.3,
          },
          AMZN: {
            peRatio: 45.2,
            marketCap: 1.6e12,
            revenueGrowth: 0.1,
            debtToEquity: 1.5,
          },
          TSLA: {
            peRatio: 65.3,
            marketCap: 8.5e11,
            revenueGrowth: 0.25,
            debtToEquity: 0.4,
          },
          NVDA: {
            peRatio: 85.7,
            marketCap: 1.2e12,
            revenueGrowth: 0.35,
            debtToEquity: 0.2,
          },
          META: {
            peRatio: 22.4,
            marketCap: 9.2e11,
            revenueGrowth: 0.18,
            debtToEquity: 0.5,
          },
          NFLX: {
            peRatio: 38.9,
            marketCap: 2.1e11,
            revenueGrowth: 0.12,
            debtToEquity: 1.8,
          },
        }

        const data = baseData[symbol] || {
          peRatio: 25 + Math.random() * 30,
          marketCap: 1e11 + Math.random() * 1e12,
          revenueGrowth: 0.05 + Math.random() * 0.2,
          debtToEquity: 0.5 + Math.random() * 1.5,
        }

        return {
          peRatio: data.peRatio,
          pbRatio: data.peRatio * 0.3 + Math.random() * 2,
          debtToEquity: data.debtToEquity,
          returnOnEquity: 0.15 + Math.random() * 0.2,
          profitMargins: 0.1 + Math.random() * 0.25,
          marketCap: data.marketCap,
          enterpriseValue: data.marketCap * (1 + Math.random() * 0.3),
          beta: 0.8 + Math.random() * 0.8,
          revenueGrowth: data.revenueGrowth,
          earningsGrowth: data.revenueGrowth * (0.8 + Math.random() * 0.4),
          dividendYield: Math.random() * 0.05,
          payoutRatio: Math.random() * 0.4,
        }
      }

      // Calculate technical indicators
      function calculateIndicators(data) {
        const indicators = {
          rsi: calculateRSI(data),
          macd: calculateMACD(data),
          ma20: calculateMA(data, 20),
          ma50: calculateMA(data, 50),
          bb: calculateBollingerBands(data, 20),
        }
        return indicators
      }

      function calculateRSI(data, period = 14) {
        if (data.length < period + 1) return 50

        let gains = 0
        let losses = 0

        for (let i = 1; i <= period; i++) {
          const change =
            data[data.length - i].close - data[data.length - i - 1].close
          if (change > 0) gains += change
          else losses -= change
        }

        const avgGain = gains / period
        const avgLoss = losses / period
        const rs = avgGain / avgLoss
        return 100 - 100 / (1 + rs)
      }

      function calculateMACD(data) {
        const ema12 = calculateEMA(data, 12)
        const ema26 = calculateEMA(data, 26)
        return ema12 - ema26
      }

      function calculateEMA(data, period) {
        const multiplier = 2 / (period + 1)
        let ema = data[0].close

        for (let i = 1; i < data.length; i++) {
          ema = data[i].close * multiplier + ema * (1 - multiplier)
        }

        return ema
      }

      function calculateMA(data, period) {
        if (data.length < period) return data[data.length - 1].close

        const sum = data.slice(-period).reduce((acc, d) => acc + d.close, 0)
        return sum / period
      }

      function calculateBollingerBands(data, period = 20) {
        if (data.length < period) return { upper: 0, middle: 0, lower: 0 }

        const prices = data.slice(-period).map((d) => d.close)
        const sma = prices.reduce((a, b) => a + b, 0) / period
        const variance =
          prices.reduce((acc, price) => acc + Math.pow(price - sma, 2), 0) /
          period
        const stdDev = Math.sqrt(variance)

        return {
          upper: sma + stdDev * 2,
          middle: sma,
          lower: sma - stdDev * 2,
        }
      }

      // Enhanced technical analysis with advanced indicators
      function calculateAdvancedIndicators(data) {
        const indicators = {
          // Basic indicators
          rsi: calculateRSI(data),
          macd: calculateMACD(data),
          ma20: calculateMA(data, 20),
          ma50: calculateMA(data, 50),
          ma200: calculateMA(data, 200),

          // Advanced momentum indicators
          stochRSI: calculateStochRSI(data),
          williamsR: calculateWilliamsR(data),
          cci: calculateCCI(data),

          // Volatility indicators
          bb: calculateBollingerBands(data, 20),
          atr: calculateATR(data, 14),
          keltner: calculateKeltnerChannels(data),

          // Volume indicators
          obv: calculateOBV(data),
          vwap: calculateVWAP(data),
          mfi: calculateMFI(data),

          // Trend indicators
          adx: calculateADX(data),
          ichimoku: calculateIchimoku(data),

          // Support/Resistance
          support: calculateSupportLevels(data),
          resistance: calculateResistanceLevels(data),

          // Pattern recognition
          patterns: detectCandlestickPatterns(data),
        }

        return indicators
      }

      // Stochastic RSI
      function calculateStochRSI(data, period = 14) {
        const rsiValues = []
        for (let i = period; i < data.length; i++) {
          rsiValues.push(calculateRSI(data.slice(0, i + 1)))
        }

        if (rsiValues.length < period) return 50

        const recentRSI = rsiValues.slice(-period)
        const minRSI = Math.min(...recentRSI)
        const maxRSI = Math.max(...recentRSI)

        return (
          ((rsiValues[rsiValues.length - 1] - minRSI) / (maxRSI - minRSI)) * 100
        )
      }

      // Williams %R
      function calculateWilliamsR(data, period = 14) {
        if (data.length < period) return -50

        const recent = data.slice(-period)
        const highest = Math.max(...recent.map((d) => d.high))
        const lowest = Math.min(...recent.map((d) => d.low))
        const current = data[data.length - 1].close

        return ((highest - current) / (highest - lowest)) * -100
      }

      // Commodity Channel Index
      function calculateCCI(data, period = 20) {
        if (data.length < period) return 0

        const recent = data.slice(-period)
        const typicalPrices = recent.map((d) => (d.high + d.low + d.close) / 3)
        const sma = typicalPrices.reduce((a, b) => a + b, 0) / period
        const meanDeviation =
          typicalPrices.reduce((sum, tp) => sum + Math.abs(tp - sma), 0) /
          period

        const currentTP =
          (data[data.length - 1].high +
            data[data.length - 1].low +
            data[data.length - 1].close) /
          3
        return (currentTP - sma) / (0.015 * meanDeviation)
      }

      // Average True Range
      function calculateATR(data, period = 14) {
        if (data.length < period + 1) return 0

        const trueRanges = []
        for (let i = 1; i < data.length; i++) {
          const high = data[i].high
          const low = data[i].low
          const prevClose = data[i - 1].close

          const tr1 = high - low
          const tr2 = Math.abs(high - prevClose)
          const tr3 = Math.abs(low - prevClose)

          trueRanges.push(Math.max(tr1, tr2, tr3))
        }

        const recentTR = trueRanges.slice(-period)
        return recentTR.reduce((a, b) => a + b, 0) / period
      }

      // Keltner Channels
      function calculateKeltnerChannels(data, period = 20) {
        const atr = calculateATR(data, period)
        const ema = calculateEMA(data, period)

        return {
          upper: ema + 2 * atr,
          middle: ema,
          lower: ema - 2 * atr,
        }
      }

      // On-Balance Volume
      function calculateOBV(data) {
        let obv = 0
        for (let i = 1; i < data.length; i++) {
          if (data[i].close > data[i - 1].close) {
            obv += data[i].volume
          } else if (data[i].close < data[i - 1].close) {
            obv -= data[i].volume
          }
        }
        return obv
      }

      // Volume Weighted Average Price
      function calculateVWAP(data) {
        let cumulativeTPV = 0
        let cumulativeVolume = 0

        for (const day of data) {
          const typicalPrice = (day.high + day.low + day.close) / 3
          cumulativeTPV += typicalPrice * day.volume
          cumulativeVolume += day.volume
        }

        return cumulativeVolume > 0 ? cumulativeTPV / cumulativeVolume : 0
      }

      // Money Flow Index
      function calculateMFI(data, period = 14) {
        if (data.length < period + 1) return 50

        const moneyFlows = []
        for (let i = 1; i < data.length; i++) {
          const typicalPrice = (data[i].high + data[i].low + data[i].close) / 3
          const prevTypicalPrice =
            (data[i - 1].high + data[i - 1].low + data[i - 1].close) / 3

          const moneyFlow = typicalPrice * data[i].volume
          moneyFlows.push({
            flow: moneyFlow,
            positive: typicalPrice > prevTypicalPrice,
          })
        }

        const recent = moneyFlows.slice(-period)
        const positiveFlow = recent
          .filter((mf) => mf.positive)
          .reduce((sum, mf) => sum + mf.flow, 0)
        const negativeFlow = recent
          .filter((mf) => !mf.positive)
          .reduce((sum, mf) => sum + mf.flow, 0)

        const moneyRatio = positiveFlow / negativeFlow
        return 100 - 100 / (1 + moneyRatio)
      }

      // Average Directional Index
      function calculateADX(data, period = 14) {
        if (data.length < period + 1) return 0

        const directionalMovements = []
        for (let i = 1; i < data.length; i++) {
          const highDiff = data[i].high - data[i - 1].high
          const lowDiff = data[i - 1].low - data[i].low

          let plusDM = 0
          let minusDM = 0

          if (highDiff > lowDiff && highDiff > 0) {
            plusDM = highDiff
          }
          if (lowDiff > highDiff && lowDiff > 0) {
            minusDM = lowDiff
          }

          directionalMovements.push({ plusDM, minusDM })
        }

        const recent = directionalMovements.slice(-period)
        const avgPlusDM =
          recent.reduce((sum, dm) => sum + dm.plusDM, 0) / period
        const avgMinusDM =
          recent.reduce((sum, dm) => sum + dm.minusDM, 0) / period

        const dx =
          (Math.abs(avgPlusDM - avgMinusDM) / (avgPlusDM + avgMinusDM)) * 100
        return dx
      }

      // Ichimoku Cloud
      function calculateIchimoku(data) {
        if (data.length < 52) return null

        const high9 = Math.max(...data.slice(-9).map((d) => d.high))
        const low9 = Math.min(...data.slice(-9).map((d) => d.low))
        const tenkan = (high9 + low9) / 2

        const high26 = Math.max(...data.slice(-26).map((d) => d.high))
        const low26 = Math.min(...data.slice(-26).map((d) => d.low))
        const kijun = (high26 + low26) / 2

        const senkouA = (tenkan + kijun) / 2
        const senkouB =
          (Math.max(...data.slice(-52).map((d) => d.high)) +
            Math.min(...data.slice(-52).map((d) => d.low))) /
          2

        return { tenkan, kijun, senkouA, senkouB }
      }

      // Support and Resistance Levels
      function calculateSupportLevels(data) {
        const lows = data.map((d) => d.low)
        const supportLevels = []

        for (let i = 2; i < lows.length - 2; i++) {
          if (
            lows[i] < lows[i - 1] &&
            lows[i] < lows[i - 2] &&
            lows[i] < lows[i + 1] &&
            lows[i] < lows[i + 2]
          ) {
            supportLevels.push(lows[i])
          }
        }

        return supportLevels.slice(-5) // Return last 5 support levels
      }

      function calculateResistanceLevels(data) {
        const highs = data.map((d) => d.high)
        const resistanceLevels = []

        for (let i = 2; i < highs.length - 2; i++) {
          if (
            highs[i] > highs[i - 1] &&
            highs[i] > highs[i - 2] &&
            highs[i] > highs[i + 1] &&
            highs[i] > highs[i + 2]
          ) {
            resistanceLevels.push(highs[i])
          }
        }

        return resistanceLevels.slice(-5) // Return last 5 resistance levels
      }

      // Candlestick Pattern Detection
      function detectCandlestickPatterns(data) {
        if (data.length < 3) return []

        const patterns = []
        const recent = data.slice(-3)

        // Doji
        const current = recent[recent.length - 1]
        const bodySize = Math.abs(current.close - current.open)
        const totalRange = current.high - current.low

        if (bodySize / totalRange < 0.1) {
          patterns.push("Doji")
        }

        // Hammer
        if (
          bodySize / totalRange < 0.3 &&
          (current.high - Math.max(current.open, current.close)) / totalRange <
            0.1
        ) {
          patterns.push("Hammer")
        }

        // Shooting Star
        if (
          bodySize / totalRange < 0.3 &&
          (Math.min(current.open, current.close) - current.low) / totalRange <
            0.1
        ) {
          patterns.push("Shooting Star")
        }

        return patterns
      }

      // Generate multi-timeframe data
      async function fetchMultiTimeframeData(symbol) {
        console.log("Generating multi-timeframe data...")

        const timeframes = {
          "1H": "1h",
          "4H": "4h",
          "1D": "1d",
          "1W": "5d",
        }

        const data = {}

        for (const [label, interval] of Object.entries(timeframes)) {
          // Generate realistic data for each timeframe
          const timeframeData = generateRealisticMockData(symbol).slice(-30) // Last 30 days
          data[label] = timeframeData
        }

        console.log("Multi-timeframe data generated successfully")
        return data
      }

      // Fibonacci Retracements
      function calculateFibonacciRetracements(data) {
        if (data.length < 20) return null

        const highs = data.map((d) => d.high)
        const lows = data.map((d) => d.low)

        const swingHigh = Math.max(...highs.slice(-20))
        const swingLow = Math.min(...lows.slice(-20))
        const range = swingHigh - swingLow

        return {
          swingHigh,
          swingLow,
          range,
          levels: {
            0: swingHigh,
            0.236: swingHigh - range * 0.236,
            0.382: swingHigh - range * 0.382,
            0.5: swingHigh - range * 0.5,
            0.618: swingHigh - range * 0.618,
            0.786: swingHigh - range * 0.786,
            1: swingLow,
          },
        }
      }

      // Elliott Wave Analysis
      function analyzeElliottWaves(data) {
        if (data.length < 50) return null

        const prices = data.map((d) => d.close)
        const waves = []
        let currentWave = 1
        let waveStart = 0
        let direction = 1 // 1 for up, -1 for down

        for (let i = 1; i < prices.length; i++) {
          const priceChange = prices[i] - prices[i - 1]
          const currentDirection = Math.sign(priceChange)

          if (currentDirection !== direction) {
            // Wave completed
            waves.push({
              wave: currentWave,
              start: waveStart,
              end: i - 1,
              startPrice: prices[waveStart],
              endPrice: prices[i - 1],
              length: i - waveStart,
              direction: direction,
            })

            waveStart = i - 1
            direction = currentDirection
            currentWave = currentWave === 5 ? 1 : currentWave + 1
          }
        }

        // Add final wave
        if (waveStart < prices.length - 1) {
          waves.push({
            wave: currentWave,
            start: waveStart,
            end: prices.length - 1,
            startPrice: prices[waveStart],
            endPrice: prices[prices.length - 1],
            length: prices.length - waveStart,
            direction: direction,
          })
        }

        return waves.slice(-10) // Return last 10 waves
      }

      // Harmonic Patterns Detection
      function detectHarmonicPatterns(data) {
        if (data.length < 20) return []

        const patterns = []
        const prices = data.map((d) => d.close)

        // Gartley Pattern
        const gartley = detectGartleyPattern(prices)
        if (gartley) patterns.push(gartley)

        // Butterfly Pattern
        const butterfly = detectButterflyPattern(prices)
        if (butterfly) patterns.push(butterfly)

        // Bat Pattern
        const bat = detectBatPattern(prices)
        if (bat) patterns.push(bat)

        // Crab Pattern
        const crab = detectCrabPattern(prices)
        if (crab) patterns.push(crab)

        return patterns
      }

      function detectGartleyPattern(prices) {
        if (prices.length < 10) return null

        const recent = prices.slice(-10)
        const swings = findSwingPoints(recent)

        if (swings.length < 4) return null

        const [X, A, B, C, D] = swings.slice(-5)

        // Gartley ratios: XA=100%, AB=61.8%, BC=38.2-88.6%, CD=127.2-161.8%
        const xa = Math.abs(A - X)
        const ab = Math.abs(B - A)
        const bc = Math.abs(C - B)
        const cd = Math.abs(D - C)

        const abRatio = ab / xa
        const bcRatio = bc / ab
        const cdRatio = cd / bc

        if (
          Math.abs(abRatio - 0.618) < 0.05 &&
          bcRatio >= 0.382 &&
          bcRatio <= 0.886 &&
          cdRatio >= 1.272 &&
          cdRatio <= 1.618
        ) {
          return {
            pattern: "Gartley",
            confidence: calculatePatternConfidence(
              [abRatio, bcRatio, cdRatio],
              [0.618, 0.5, 1.414]
            ),
            points: { X, A, B, C, D },
          }
        }

        return null
      }

      function detectButterflyPattern(prices) {
        if (prices.length < 10) return null

        const recent = prices.slice(-10)
        const swings = findSwingPoints(recent)

        if (swings.length < 4) return null

        const [X, A, B, C, D] = swings.slice(-5)

        // Butterfly ratios: XA=100%, AB=78.6%, BC=38.2-88.6%, CD=161.8-224%
        const xa = Math.abs(A - X)
        const ab = Math.abs(B - A)
        const bc = Math.abs(C - B)
        const cd = Math.abs(D - C)

        const abRatio = ab / xa
        const bcRatio = bc / ab
        const cdRatio = cd / bc

        if (
          Math.abs(abRatio - 0.786) < 0.05 &&
          bcRatio >= 0.382 &&
          bcRatio <= 0.886 &&
          cdRatio >= 1.618 &&
          cdRatio <= 2.24
        ) {
          return {
            pattern: "Butterfly",
            confidence: calculatePatternConfidence(
              [abRatio, bcRatio, cdRatio],
              [0.786, 0.5, 1.618]
            ),
            points: { X, A, B, C, D },
          }
        }

        return null
      }

      function detectBatPattern(prices) {
        if (prices.length < 10) return null

        const recent = prices.slice(-10)
        const swings = findSwingPoints(recent)

        if (swings.length < 4) return null

        const [X, A, B, C, D] = swings.slice(-5)

        // Bat ratios: XA=100%, AB=38.2-50%, BC=38.2-88.6%, CD=161.8-261.8%
        const xa = Math.abs(A - X)
        const ab = Math.abs(B - A)
        const bc = Math.abs(C - B)
        const cd = Math.abs(D - C)

        const abRatio = ab / xa
        const bcRatio = bc / ab
        const cdRatio = cd / bc

        if (
          abRatio >= 0.382 &&
          abRatio <= 0.5 &&
          bcRatio >= 0.382 &&
          bcRatio <= 0.886 &&
          cdRatio >= 1.618 &&
          cdRatio <= 2.618
        ) {
          return {
            pattern: "Bat",
            confidence: calculatePatternConfidence(
              [abRatio, bcRatio, cdRatio],
              [0.45, 0.5, 2.0]
            ),
            points: { X, A, B, C, D },
          }
        }

        return null
      }

      function detectCrabPattern(prices) {
        if (prices.length < 10) return null

        const recent = prices.slice(-10)
        const swings = findSwingPoints(recent)

        if (swings.length < 4) return null

        const [X, A, B, C, D] = swings.slice(-5)

        // Crab ratios: XA=100%, AB=38.2-61.8%, BC=38.2-88.6%, CD=261.8-361.8%
        const xa = Math.abs(A - X)
        const ab = Math.abs(B - A)
        const bc = Math.abs(C - B)
        const cd = Math.abs(D - C)

        const abRatio = ab / xa
        const bcRatio = bc / ab
        const cdRatio = cd / bc

        if (
          abRatio >= 0.382 &&
          abRatio <= 0.618 &&
          bcRatio >= 0.382 &&
          bcRatio <= 0.886 &&
          cdRatio >= 2.618 &&
          cdRatio <= 3.618
        ) {
          return {
            pattern: "Crab",
            confidence: calculatePatternConfidence(
              [abRatio, bcRatio, cdRatio],
              [0.5, 0.5, 3.0]
            ),
            points: { X, A, B, C, D },
          }
        }

        return null
      }

      function findSwingPoints(prices) {
        const swings = []

        for (let i = 2; i < prices.length - 2; i++) {
          // Swing high
          if (
            prices[i] > prices[i - 1] &&
            prices[i] > prices[i - 2] &&
            prices[i] > prices[i + 1] &&
            prices[i] > prices[i + 2]
          ) {
            swings.push(prices[i])
          }
          // Swing low
          else if (
            prices[i] < prices[i - 1] &&
            prices[i] < prices[i - 2] &&
            prices[i] < prices[i + 1] &&
            prices[i] < prices[i + 2]
          ) {
            swings.push(prices[i])
          }
        }

        return swings
      }

      function calculatePatternConfidence(actual, expected) {
        let totalError = 0
        for (let i = 0; i < actual.length; i++) {
          totalError += Math.abs(actual[i] - expected[i]) / expected[i]
        }
        const avgError = totalError / actual.length
        return Math.max(0, 100 - avgError * 100)
      }

      // Volume Profile Analysis
      function calculateVolumeProfile(data) {
        if (data.length < 20) return null

        const priceVolume = {}

        for (const day of data) {
          const priceLevel = Math.round(day.close * 100) / 100
          if (!priceVolume[priceLevel]) {
            priceVolume[priceLevel] = 0
          }
          priceVolume[priceLevel] += day.volume
        }

        const levels = Object.entries(priceVolume)
          .map(([price, volume]) => ({ price: parseFloat(price), volume }))
          .sort((a, b) => b.volume - a.volume)

        const totalVolume = levels.reduce((sum, level) => sum + level.volume, 0)

        // Find POC (Point of Control) - price level with highest volume
        const poc = levels[0]

        // Find Value Area (70% of volume)
        let cumulativeVolume = 0
        const valueArea = []

        for (const level of levels) {
          cumulativeVolume += level.volume
          valueArea.push(level)

          if (cumulativeVolume / totalVolume >= 0.7) break
        }

        return {
          poc,
          valueArea,
          totalVolume,
          levels: levels.slice(0, 20), // Top 20 volume levels
        }
      }

      // Order Flow Visualization (simplified)
      function analyzeOrderFlow(data) {
        if (data.length < 20) return null

        const recent = data.slice(-20)
        const orderFlow = {
          buyingPressure: 0,
          sellingPressure: 0,
          volumeSpikes: [],
          priceRejections: [],
        }

        for (let i = 1; i < recent.length; i++) {
          const current = recent[i]
          const previous = recent[i - 1]

          // Calculate buying/selling pressure
          if (current.close > previous.close) {
            orderFlow.buyingPressure += current.volume
          } else if (current.close < previous.close) {
            orderFlow.sellingPressure += current.volume
          }

          // Detect volume spikes (>2x average)
          const avgVolume =
            recent.slice(0, i).reduce((sum, d) => sum + d.volume, 0) / i
          if (current.volume > avgVolume * 2) {
            orderFlow.volumeSpikes.push({
              date: current.date,
              volume: current.volume,
              price: current.close,
              ratio: current.volume / avgVolume,
            })
          }

          // Detect price rejections (long wicks)
          const bodySize = Math.abs(current.close - current.open)
          const totalRange = current.high - current.low
          const wickRatio = (totalRange - bodySize) / totalRange

          if (wickRatio > 0.6) {
            orderFlow.priceRejections.push({
              date: current.date,
              price: current.close,
              wickRatio,
              direction: current.close > current.open ? "bullish" : "bearish",
            })
          }
        }

        return orderFlow
      }

      // Update UI functions
      function updateStockInfo(symbol, data) {
        const latest = data[data.length - 1]
        const marketCap =
          Math.floor(Math.random() * 1000000000000) + 100000000000
        const sectors = [
          "Technology",
          "Healthcare",
          "Finance",
          "Consumer Goods",
          "Energy",
        ]
        const sector = sectors[Math.floor(Math.random() * sectors.length)]

        stockInfoCard.innerHTML = `
                <div class="card-content">
                    <p class="regular-text">üí∞ Current Price: <span class="bold-number">$${latest.close.toFixed(
                      2
                    )}</span></p>
                    <p class="regular-text">üìà Market Cap: <span class="bold-number">$${marketCap.toLocaleString()}</span></p>
                    <p class="regular-text">üè¢ Sector: <span class="bold-text">${sector}</span></p>
                    <p class="regular-text">üìÖ Data Points: <span class="bold-number">${
                      data.length
                    } days</span></p>
                    <p class="regular-text">üìä Volume: <span class="bold-number">${latest.volume.toLocaleString()}</span></p>
                </div>
            `
      }

      function updateRecommendation(data) {
        const recommendation = generateRecommendation(data)

        recommendationCard.innerHTML = `
                <div class="card-content">
                    <div class="alert alert-${recommendation.color}">${
          recommendation.recommendation
        } - Confidence: ${recommendation.confidence.toFixed(0)}%</div>
                    <h6 class="bold-text" style="margin-top: 1rem; margin-bottom: 0.5rem;">Key Signals:</h6>
                    <ul>
                        ${recommendation.signals
                          .map((signal) => `<li>${signal}</li>`)
                          .join("")}
                    </ul>
                </div>
            `
      }

      function updateTechnicalAnalysis(data) {
        const recommendation = generateRecommendation(data)
        const indicators = calculateIndicators(data)

        technicalContent.innerHTML = `
                <div class="card-content">
                    <p class="regular-text">RSI: <span class="bold-number">${recommendation.rsi.toFixed(
                      1
                    )}</span></p>
                    <p class="regular-text">Price Change (20d): <span class="bold-number">${
                      recommendation.price_change >= 0 ? "+" : ""
                    }${recommendation.price_change.toFixed(1)}%</span></p>
                    <p class="regular-text">Volume Ratio: <span class="bold-number">${recommendation.volume_ratio.toFixed(
                      1
                    )}x average</span></p>
                    <p class="regular-text">MACD: <span class="bold-number">${indicators.macd.toFixed(
                      3
                    )}</span></p>
                    <p class="regular-text">Data Quality: <span class="bold-text">Good (${
                      data.length
                    } days)</span></p>
                </div>
            `
      }

      function updateRiskAssessment(data) {
        const returns = []
        for (let i = 1; i < data.length; i++) {
          returns.push((data[i].close - data[i - 1].close) / data[i - 1].close)
        }

        const volatility =
          Math.sqrt(
            returns.reduce((sum, r) => sum + r * r, 0) / returns.length
          ) *
          Math.sqrt(252) *
          100
        const maxDrawdown = calculateMaxDrawdown(data)
        const sharpeRatio =
          (returns.reduce((sum, r) => sum + r, 0) /
            returns.length /
            Math.sqrt(
              returns.reduce((sum, r) => sum + r * r, 0) / returns.length
            )) *
          Math.sqrt(252)

        let riskLevel, riskColor
        if (volatility > 30) {
          riskLevel = "High"
          riskColor = "danger"
        } else if (volatility > 20) {
          riskLevel = "Moderate"
          riskColor = "warning"
        } else {
          riskLevel = "Low"
          riskColor = "success"
        }

        riskContent.innerHTML = `
                <div class="card-content">
                    <div class="alert alert-${riskColor}">Risk Level: ${riskLevel}</div>
                    <p class="regular-text">Volatility: <span class="bold-number">${volatility.toFixed(
                      1
                    )}%</span></p>
                    <p class="regular-text">Max Drawdown: <span class="bold-number">${maxDrawdown.toFixed(
                      1
                    )}%</span></p>
                    <p class="regular-text">Sharpe Ratio: <span class="bold-number">${sharpeRatio.toFixed(
                      2
                    )}</span></p>
                    <p class="regular-text">Beta: <span class="bold-text">N/A</span></p>
                </div>
            `
      }

      function calculateMaxDrawdown(data) {
        let maxDrawdown = 0
        let peak = data[0].close

        for (let i = 1; i < data.length; i++) {
          if (data[i].close > peak) {
            peak = data[i].close
          }
          const drawdown = ((data[i].close - peak) / peak) * 100
          if (drawdown < maxDrawdown) {
            maxDrawdown = drawdown
          }
        }

        return Math.abs(maxDrawdown)
      }

      function updateChart(symbol, data) {
        chartContainer.style.display = "block"

        if (currentChart) {
          currentChart.destroy()
        }

        const ctx = priceChart.getContext("2d")
        const chartData = {
          labels: data.map((d) => d.date),
          datasets: [
            {
              label: "Close Price",
              data: data.map((d) => d.close),
              borderColor: "#8b0000",
              backgroundColor: "rgba(139, 0, 0, 0.1)",
              borderWidth: 2,
              fill: false,
            },
          ],
        }

        currentChart = new Chart(ctx, {
          type: "line",
          data: chartData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: false,
              },
              legend: {
                labels: {
                  color: "#ffffff",
                },
              },
            },
            scales: {
              x: {
                grid: {
                  color: "rgba(139, 0, 0, 0.2)",
                },
                ticks: {
                  color: "#ffffff",
                  maxTicksLimit: 10,
                },
              },
              y: {
                grid: {
                  color: "rgba(139, 0, 0, 0.2)",
                },
                ticks: {
                  color: "#ffffff",
                },
              },
            },
            layout: {
              padding: {
                top: 10,
                bottom: 10,
              },
            },
          },
        })
      }

      function updateStockTitle(symbol) {
        const companies = {
          AAPL: "Apple Inc.",
          MSFT: "Microsoft Corporation",
          GOOGL: "Alphabet Inc.",
          AMZN: "Amazon.com Inc.",
          TSLA: "Tesla Inc.",
          NVDA: "NVIDIA Corporation",
          META: "Meta Platforms Inc.",
          NFLX: "Netflix Inc.",
        }

        const companyName = companies[symbol] || symbol
        stockTitle.textContent = `üìä ${symbol} - ${companyName}`
      }

      // Utility functions
      function showLoading(message) {
        loadingOutput.innerHTML = `
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                    ${message}
                </div>
            `
      }

      function hideLoading() {
        loadingOutput.innerHTML = ""
      }

      function showError(message) {
        loadingOutput.innerHTML = `
                <div class="error-message">
                    ${message}
                </div>
            `
      }

      // Filter functions
      function setFilter(filter) {
        currentFilter = filter

        // Update active button
        document.querySelectorAll(".filter-btn").forEach((btn) => {
          btn.classList.remove("filter-btn-active")
        })

        switch (filter) {
          case "all":
            filterAll.classList.add("filter-btn-active")
            break
          case "buy":
            filterBuy.classList.add("filter-btn-active")
            break
          case "hold":
            filterHold.classList.add("filter-btn-active")
            break
          case "sell":
            filterSell.classList.add("filter-btn-active")
            break
        }

        updateStockList()
      }

      function updateStockList() {
        if (allStocksData.length === 0) {
          stockListSection.style.display = "none"
          return
        }

        stockListSection.style.display = "block"

        // Filter stocks based on current filter
        let filteredStocks = allStocksData
        if (currentFilter !== "all") {
          filteredStocks = allStocksData.filter(
            (stock) => stock.recommendation.toLowerCase() === currentFilter
          )
        }

        // Sort by confidence (highest first)
        filteredStocks.sort((a, b) => b.confidence - a.confidence)

        // Generate HTML for stock list
        stockList.innerHTML = filteredStocks
          .map(
            (stock) => `
           <div class="stock-item" onclick="selectStock('${stock.symbol}')">
             <div class="stock-item-header">
               <div class="stock-symbol">${stock.symbol}</div>
               <div class="stock-recommendation recommendation-${stock.recommendation.toLowerCase()}">
                 ${stock.recommendation}
               </div>
             </div>
             <div class="stock-details">
               <div class="stock-detail">
                 <div class="stock-detail-label">Price</div>
                 $${stock.price.toFixed(2)}
               </div>
               <div class="stock-detail">
                 <div class="stock-detail-label">Change</div>
                 ${
                   stock.priceChange >= 0 ? "+" : ""
                 }${stock.priceChange.toFixed(1)}%
               </div>
               <div class="stock-detail">
                 <div class="stock-detail-label">Confidence</div>
                 ${stock.confidence.toFixed(0)}%
               </div>
               <div class="stock-detail">
                 <div class="stock-detail-label">RSI</div>
                 ${stock.rsi.toFixed(1)}
               </div>
             </div>
           </div>
         `
          )
          .join("")
      }

      function selectStock(symbol) {
        // Find the stock data
        const stock = allStocksData.find((s) => s.symbol === symbol)
        if (stock) {
          // Update the input and analyze
          symbolInput.value = symbol
          analyzeStock()

          // Scroll to the chart
          chartContainer.scrollIntoView({ behavior: "smooth" })
        }
      }

      // Initialize with default data
      window.addEventListener("load", function () {
        // Add some popular stocks for demonstration (after initial AAPL analysis)
        setTimeout(() => {
          const popularStocks = [
            "MSFT",
            "GOOGL",
            "AMZN",
            "TSLA",
            "NVDA",
            "META",
            "NFLX",
          ]
          popularStocks.forEach((symbol, index) => {
            setTimeout(() => {
              if (symbolInput) {
                symbolInput.value = symbol
                analyzeStock()
              }
            }, (index + 2) * 1000) // Analyze each stock with 2 second delay after initial
          })
        }, 3000)
      })

      // AI-Powered Pattern Recognition System
      class PatternRecognitionAI {
        constructor() {
          this.patterns = {
            // Chart patterns
            chart: [
              "Head and Shoulders",
              "Inverse Head and Shoulders",
              "Double Top",
              "Double Bottom",
              "Triangle",
              "Wedge",
              "Flag",
              "Pennant",
              "Cup and Handle",
              "Rounding Bottom",
            ],

            // Candlestick patterns
            candlestick: [
              "Doji",
              "Hammer",
              "Shooting Star",
              "Engulfing",
              "Morning Star",
              "Evening Star",
              "Three White Soldiers",
              "Three Black Crows",
              "Hanging Man",
              "Inverted Hammer",
            ],

            // Breakout patterns
            breakout: [
              "Channel Breakout",
              "Triangle Breakout",
              "Flag Breakout",
              "Cup Breakout",
              "Range Breakout",
            ],

            // Trend reversal patterns
            reversal: [
              "Double Top Reversal",
              "Double Bottom Reversal",
              "Head and Shoulders Reversal",
              "Inverse Head and Shoulders Reversal",
              "Rounding Top",
              "Rounding Bottom",
            ],
          }

          this.featureExtractors = {
            priceAction: this.extractPriceActionFeatures,
            volume: this.extractVolumeFeatures,
            momentum: this.extractMomentumFeatures,
            volatility: this.extractVolatilityFeatures,
          }
        }

        // Main pattern detection method
        detectPatterns(data) {
          const features = this.extractAllFeatures(data)
          const patterns = {
            chart: this.detectChartPatterns(data, features),
            candlestick: detectCandlestickPatterns(data),
            breakout: this.detectBreakoutPatterns(data, features),
            reversal: this.detectReversalPatterns(data, features),
            harmonic: detectHarmonicPatterns(data),
            elliott: analyzeElliottWaves(data),
          }

          return this.rankPatterns(patterns, features)
        }

        // Extract comprehensive features for ML
        extractAllFeatures(data) {
          return {
            priceAction: this.extractPriceActionFeatures(data),
            volume: this.extractVolumeFeatures(data),
            momentum: this.extractMomentumFeatures(data),
            volatility: this.extractVolatilityFeatures(data),
            technical: this.extractTechnicalFeatures(data),
          }
        }

        extractPriceActionFeatures(data) {
          if (data.length < 20) return {}

          const prices = data.map((d) => d.close)
          const highs = data.map((d) => d.high)
          const lows = data.map((d) => d.low)

          // Price trends
          const shortTrend = this.calculateTrend(prices.slice(-5))
          const mediumTrend = this.calculateTrend(prices.slice(-10))
          const longTrend = this.calculateTrend(prices.slice(-20))

          // Price ranges
          const recentRange =
            Math.max(...highs.slice(-5)) - Math.min(...lows.slice(-5))
          const avgRange =
            (Math.max(...highs) - Math.min(...lows)) / highs.length

          // Support/Resistance levels
          const support = Math.min(...lows.slice(-10))
          const resistance = Math.max(...highs.slice(-10))
          const currentPrice = prices[prices.length - 1]

          return {
            shortTrend,
            mediumTrend,
            longTrend,
            rangeRatio: recentRange / avgRange,
            supportDistance: (currentPrice - support) / currentPrice,
            resistanceDistance: (resistance - currentPrice) / currentPrice,
            pricePosition: (currentPrice - support) / (resistance - support),
          }
        }

        extractVolumeFeatures(data) {
          if (data.length < 20) return {}

          const volumes = data.map((d) => d.volume)
          const prices = data.map((d) => d.close)

          // Volume trends
          const volumeTrend = this.calculateTrend(volumes.slice(-10))
          const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length
          const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5

          // Volume-price relationship
          const volumePriceCorrelation = this.calculateCorrelation(
            prices.slice(-10),
            volumes.slice(-10)
          )

          // Volume spikes
          const volumeSpikes = volumes.filter((v) => v > avgVolume * 2).length

          return {
            volumeTrend,
            volumeRatio: recentVolume / avgVolume,
            volumePriceCorrelation,
            volumeSpikes,
            volumeConsistency: this.calculateConsistency(volumes.slice(-10)),
          }
        }

        extractMomentumFeatures(data) {
          if (data.length < 20) return {}

          const prices = data.map((d) => d.close)

          // Momentum indicators
          const rsi = calculateRSI(data)
          const macd = calculateMACD(data)
          const stochRSI = calculateStochRSI(data)

          // Price momentum
          const momentum5 =
            (prices[prices.length - 1] - prices[prices.length - 6]) /
            prices[prices.length - 6]
          const momentum10 =
            (prices[prices.length - 1] - prices[prices.length - 11]) /
            prices[prices.length - 11]

          return {
            rsi,
            macd,
            stochRSI,
            momentum5,
            momentum10,
            momentumDivergence: Math.abs(momentum5 - momentum10),
          }
        }

        extractVolatilityFeatures(data) {
          if (data.length < 20) return {}

          const prices = data.map((d) => d.close)
          const returns = []

          for (let i = 1; i < prices.length; i++) {
            returns.push((prices[i] - prices[i - 1]) / prices[i - 1])
          }

          const volatility = Math.sqrt(
            returns.reduce((sum, r) => sum + r * r, 0) / returns.length
          )
          const recentVolatility = Math.sqrt(
            returns.slice(-10).reduce((sum, r) => sum + r * r, 0) / 10
          )

          return {
            volatility,
            recentVolatility,
            volatilityRatio: recentVolatility / volatility,
            volatilityTrend: this.calculateTrend(
              returns.slice(-10).map((r) => Math.abs(r))
            ),
          }
        }

        extractTechnicalFeatures(data) {
          const indicators = calculateAdvancedIndicators(data)

          return {
            bbPosition: this.calculateBBPosition(data, indicators.bb),
            maAlignment: this.calculateMAAlignment(data, indicators),
            trendStrength: indicators.adx,
            volumeProfile: calculateVolumeProfile(data),
            orderFlow: analyzeOrderFlow(data),
          }
        }

        // Chart Pattern Detection
        detectChartPatterns(data, features) {
          const patterns = []

          // Head and Shoulders
          const headShoulders = this.detectHeadAndShoulders(data)
          if (headShoulders) patterns.push(headShoulders)

          // Double Top/Bottom
          const doubleTop = this.detectDoubleTop(data)
          if (doubleTop) patterns.push(doubleTop)

          const doubleBottom = this.detectDoubleBottom(data)
          if (doubleBottom) patterns.push(doubleBottom)

          // Triangle patterns
          const triangle = this.detectTriangle(data)
          if (triangle) patterns.push(triangle)

          // Cup and Handle
          const cupHandle = this.detectCupAndHandle(data)
          if (cupHandle) patterns.push(cupHandle)

          return patterns
        }

        detectHeadAndShoulders(data) {
          if (data.length < 30) return null

          const highs = data.map((d) => d.high)
          const peaks = this.findPeaks(highs, 5)

          if (peaks.length < 3) return null

          const [leftShoulder, head, rightShoulder] = peaks.slice(-3)

          // Check if head is higher than shoulders
          if (
            head.value > leftShoulder.value &&
            head.value > rightShoulder.value
          ) {
            // Check if shoulders are roughly at same level
            const shoulderDiff =
              Math.abs(leftShoulder.value - rightShoulder.value) /
              leftShoulder.value

            if (shoulderDiff < 0.05) {
              // 5% tolerance
              const neckline =
                Math.min(leftShoulder.value, rightShoulder.value) * 0.95
              const currentPrice = data[data.length - 1].close

              return {
                pattern: "Head and Shoulders",
                confidence: this.calculatePatternConfidence([
                  shoulderDiff,
                  (head.value - leftShoulder.value) / leftShoulder.value,
                ]),
                signal: currentPrice < neckline ? "SELL" : "NEUTRAL",
                target: neckline * 0.9, // 10% below neckline
                stopLoss: head.value * 1.02,
              }
            }
          }

          return null
        }

        detectDoubleTop(data) {
          if (data.length < 20) return null

          const highs = data.map((d) => d.high)
          const peaks = this.findPeaks(highs, 3)

          if (peaks.length < 2) return null

          const [firstTop, secondTop] = peaks.slice(-2)

          // Check if tops are roughly at same level
          const topDiff =
            Math.abs(firstTop.value - secondTop.value) / firstTop.value

          if (topDiff < 0.03) {
            // 3% tolerance
            const neckline = Math.min(
              ...highs.slice(firstTop.index, secondTop.index)
            )
            const currentPrice = data[data.length - 1].close

            return {
              pattern: "Double Top",
              confidence: this.calculatePatternConfidence([topDiff]),
              signal: currentPrice < neckline ? "SELL" : "NEUTRAL",
              target: neckline * 0.95,
              stopLoss: Math.max(firstTop.value, secondTop.value) * 1.01,
            }
          }

          return null
        }

        detectDoubleBottom(data) {
          if (data.length < 20) return null

          const lows = data.map((d) => d.low)
          const troughs = this.findTroughs(lows, 3)

          if (troughs.length < 2) return null

          const [firstBottom, secondBottom] = troughs.slice(-2)

          // Check if bottoms are roughly at same level
          const bottomDiff =
            Math.abs(firstBottom.value - secondBottom.value) / firstBottom.value

          if (bottomDiff < 0.03) {
            // 3% tolerance
            const neckline = Math.max(
              ...lows.slice(firstBottom.index, secondBottom.index)
            )
            const currentPrice = data[data.length - 1].close

            return {
              pattern: "Double Bottom",
              confidence: this.calculatePatternConfidence([bottomDiff]),
              signal: currentPrice > neckline ? "BUY" : "NEUTRAL",
              target: neckline * 1.05,
              stopLoss: Math.min(firstBottom.value, secondBottom.value) * 0.99,
            }
          }

          return null
        }

        detectTriangle(data) {
          if (data.length < 15) return null

          const highs = data.map((d) => d.high)
          const lows = data.map((d) => d.low)

          // Check for converging trendlines
          const highTrend = this.calculateTrend(highs.slice(-10))
          const lowTrend = this.calculateTrend(lows.slice(-10))

          // Symmetrical triangle (both lines converging)
          if (highTrend < 0 && lowTrend > 0) {
            return {
              pattern: "Symmetrical Triangle",
              confidence: this.calculatePatternConfidence([
                Math.abs(highTrend),
                Math.abs(lowTrend),
              ]),
              signal: "NEUTRAL",
              breakoutDirection: "UNKNOWN",
              target: this.calculateTriangleTarget(data, "symmetrical"),
            }
          }

          // Ascending triangle (flat top, rising bottom)
          if (Math.abs(highTrend) < 0.001 && lowTrend > 0.001) {
            return {
              pattern: "Ascending Triangle",
              confidence: this.calculatePatternConfidence([
                Math.abs(highTrend),
                lowTrend,
              ]),
              signal: "BUY",
              breakoutDirection: "UP",
              target: this.calculateTriangleTarget(data, "ascending"),
            }
          }

          // Descending triangle (falling top, flat bottom)
          if (highTrend < -0.001 && Math.abs(lowTrend) < 0.001) {
            return {
              pattern: "Descending Triangle",
              confidence: this.calculatePatternConfidence([
                Math.abs(highTrend),
                Math.abs(lowTrend),
              ]),
              signal: "SELL",
              breakoutDirection: "DOWN",
              target: this.calculateTriangleTarget(data, "descending"),
            }
          }

          return null
        }

        detectCupAndHandle(data) {
          if (data.length < 40) return null

          const prices = data.map((d) => d.close)

          // Look for U-shaped pattern followed by small consolidation
          const cupData = prices.slice(-30, -5)
          const handleData = prices.slice(-5)

          // Check if cup is U-shaped
          const cupStart = cupData[0]
          const cupBottom = Math.min(...cupData)
          const cupEnd = cupData[cupData.length - 1]

          const cupDepth = (cupStart - cupBottom) / cupStart
          const cupRecovery = (cupEnd - cupBottom) / cupBottom

          if (
            cupDepth > 0.1 &&
            cupRecovery > 0.8 &&
            Math.abs(cupStart - cupEnd) / cupStart < 0.05
          ) {
            // Check if handle is small consolidation
            const handleRange =
              (Math.max(...handleData) - Math.min(...handleData)) / cupEnd

            if (handleRange < 0.1) {
              return {
                pattern: "Cup and Handle",
                confidence: this.calculatePatternConfidence([
                  cupDepth,
                  cupRecovery,
                  handleRange,
                ]),
                signal: "BUY",
                target: cupEnd * 1.1, // 10% above cup rim
                stopLoss: Math.min(...handleData) * 0.98,
              }
            }
          }

          return null
        }

        // Breakout Detection
        detectBreakoutPatterns(data, features) {
          const patterns = []

          // Channel breakout
          const channelBreakout = this.detectChannelBreakout(data)
          if (channelBreakout) patterns.push(channelBreakout)

          // Support/Resistance breakout
          const supportResistanceBreakout =
            this.detectSupportResistanceBreakout(data, features)
          if (supportResistanceBreakout)
            patterns.push(supportResistanceBreakout)

          // Volume breakout
          const volumeBreakout = this.detectVolumeBreakout(data, features)
          if (volumeBreakout) patterns.push(volumeBreakout)

          return patterns
        }

        detectChannelBreakout(data) {
          if (data.length < 20) return null

          const prices = data.map((d) => d.close)
          const upperChannel = this.calculateUpperChannel(prices.slice(-15))
          const lowerChannel = this.calculateLowerChannel(prices.slice(-15))
          const currentPrice = prices[prices.length - 1]

          // Check for breakout
          if (currentPrice > upperChannel) {
            return {
              pattern: "Channel Breakout (Bullish)",
              confidence: this.calculateBreakoutConfidence(
                currentPrice,
                upperChannel
              ),
              signal: "BUY",
              target: currentPrice * 1.05,
              stopLoss: lowerChannel,
            }
          } else if (currentPrice < lowerChannel) {
            return {
              pattern: "Channel Breakout (Bearish)",
              confidence: this.calculateBreakoutConfidence(
                lowerChannel,
                currentPrice
              ),
              signal: "SELL",
              target: currentPrice * 0.95,
              stopLoss: upperChannel,
            }
          }

          return null
        }

        // Trend Reversal Detection
        detectReversalPatterns(data, features) {
          const patterns = []

          // Divergence detection
          const divergence = this.detectDivergence(data, features)
          if (divergence) patterns.push(divergence)

          // Momentum reversal
          const momentumReversal = this.detectMomentumReversal(data, features)
          if (momentumReversal) patterns.push(momentumReversal)

          // Volume climax
          const volumeClimax = this.detectVolumeClimax(data, features)
          if (volumeClimax) patterns.push(volumeClimax)

          return patterns
        }

        detectDivergence(data, features) {
          const prices = data.map((d) => d.close)
          const rsi = calculateRSI(data)

          // Price making higher highs but RSI making lower highs (bearish divergence)
          const recentPrices = prices.slice(-10)
          const recentRSI = []

          for (let i = 0; i < 10; i++) {
            recentRSI.push(
              calculateRSI(data.slice(0, data.length - 10 + i + 1))
            )
          }

          const priceHighs = this.findPeaks(recentPrices, 2)
          const rsiHighs = this.findPeaks(recentRSI, 2)

          if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const priceTrend = priceHighs[1].value > priceHighs[0].value
            const rsiTrend = rsiHighs[1].value > rsiHighs[0].value

            if (priceTrend && !rsiTrend) {
              return {
                pattern: "Bearish Divergence",
                confidence: this.calculateDivergenceConfidence(
                  priceHighs,
                  rsiHighs
                ),
                signal: "SELL",
                target: prices[prices.length - 1] * 0.95,
              }
            } else if (!priceTrend && rsiTrend) {
              return {
                pattern: "Bullish Divergence",
                confidence: this.calculateDivergenceConfidence(
                  priceHighs,
                  rsiHighs
                ),
                signal: "BUY",
                target: prices[prices.length - 1] * 1.05,
              }
            }
          }

          return null
        }

        // Utility methods
        findPeaks(data, minDistance = 1) {
          const peaks = []

          for (let i = 1; i < data.length - 1; i++) {
            if (data[i] > data[i - 1] && data[i] > data[i + 1]) {
              if (
                peaks.length === 0 ||
                i - peaks[peaks.length - 1].index >= minDistance
              ) {
                peaks.push({ index: i, value: data[i] })
              }
            }
          }

          return peaks
        }

        findTroughs(data, minDistance = 1) {
          const troughs = []

          for (let i = 1; i < data.length - 1; i++) {
            if (data[i] < data[i - 1] && data[i] < data[i + 1]) {
              if (
                troughs.length === 0 ||
                i - troughs[troughs.length - 1].index >= minDistance
              ) {
                troughs.push({ index: i, value: data[i] })
              }
            }
          }

          return troughs
        }

        calculateTrend(data) {
          if (data.length < 2) return 0

          const x = Array.from({ length: data.length }, (_, i) => i)
          const y = data

          const n = data.length
          const sumX = x.reduce((a, b) => a + b, 0)
          const sumY = y.reduce((a, b) => a + b, 0)
          const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0)
          const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0)

          const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)
          return slope
        }

        calculateCorrelation(x, y) {
          if (x.length !== y.length) return 0

          const n = x.length
          const sumX = x.reduce((a, b) => a + b, 0)
          const sumY = y.reduce((a, b) => a + b, 0)
          const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0)
          const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0)
          const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0)

          const numerator = n * sumXY - sumX * sumY
          const denominator = Math.sqrt(
            (n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY)
          )

          return denominator === 0 ? 0 : numerator / denominator
        }

        calculateConsistency(data) {
          if (data.length < 2) return 1

          const mean = data.reduce((a, b) => a + b, 0) / data.length
          const variance =
            data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /
            data.length
          const stdDev = Math.sqrt(variance)

          return 1 - stdDev / mean
        }

        calculatePatternConfidence(factors) {
          const avgFactor = factors.reduce((a, b) => a + b, 0) / factors.length
          return Math.min(100, Math.max(0, avgFactor * 100))
        }

        calculateBreakoutConfidence(price, level) {
          const distance = Math.abs(price - level) / level
          return Math.min(100, distance * 1000)
        }

        calculateDivergenceConfidence(pricePeaks, indicatorPeaks) {
          const priceStrength =
            Math.abs(pricePeaks[1].value - pricePeaks[0].value) /
            pricePeaks[0].value
          const indicatorStrength =
            Math.abs(indicatorPeaks[1].value - indicatorPeaks[0].value) /
            indicatorPeaks[0].value
          return Math.min(100, (priceStrength + indicatorStrength) * 50)
        }

        calculateTriangleTarget(data, type) {
          const prices = data.map((d) => d.close)
          const height =
            Math.max(...prices.slice(-10)) - Math.min(...prices.slice(-10))
          const currentPrice = prices[prices.length - 1]

          switch (type) {
            case "ascending":
              return currentPrice + height
            case "descending":
              return currentPrice - height
            case "symmetrical":
              return currentPrice + height // Assume breakout direction
            default:
              return currentPrice * 1.05
          }
        }

        calculateUpperChannel(prices) {
          const trend = this.calculateTrend(prices)
          const maxPrice = Math.max(...prices)
          return maxPrice + trend * prices.length
        }

        calculateLowerChannel(prices) {
          const trend = this.calculateTrend(prices)
          const minPrice = Math.min(...prices)
          return minPrice + trend * prices.length
        }

        // Rank patterns by confidence and relevance
        rankPatterns(patterns, features) {
          const allPatterns = []

          Object.entries(patterns).forEach(([category, patternList]) => {
            if (Array.isArray(patternList)) {
              patternList.forEach((pattern) => {
                allPatterns.push({
                  ...pattern,
                  category,
                  score: this.calculatePatternScore(pattern, features),
                })
              })
            }
          })

          return allPatterns.sort((a, b) => b.score - a.score).slice(0, 10) // Return top 10 patterns
        }

        calculatePatternScore(pattern, features) {
          let score = pattern.confidence || 50

          // Boost score based on pattern type
          const patternBoosts = {
            "Head and Shoulders": 1.2,
            "Double Top": 1.1,
            "Double Bottom": 1.1,
            "Cup and Handle": 1.3,
            Gartley: 1.2,
            Butterfly: 1.1,
            "Bearish Divergence": 1.4,
            "Bullish Divergence": 1.4,
          }

          score *= patternBoosts[pattern.pattern] || 1.0

          // Adjust based on market conditions
          if (features.momentum && features.momentum.rsi > 70) {
            score *= 0.8 // Reduce bullish pattern scores in overbought conditions
          } else if (features.momentum && features.momentum.rsi < 30) {
            score *= 0.8 // Reduce bearish pattern scores in oversold conditions
          }

          return Math.min(100, score)
        }

        // Missing function implementations
        detectSupportResistanceBreakout(data, features) {
          if (data.length < 20) return null

          const prices = data.map((d) => d.close)
          const currentPrice = prices[prices.length - 1]
          const support = Math.min(...prices.slice(-10))
          const resistance = Math.max(...prices.slice(-10))

          const supportDistance = (currentPrice - support) / currentPrice
          const resistanceDistance = (resistance - currentPrice) / currentPrice

          if (supportDistance < 0.02) {
            // Within 2% of support
            return {
              pattern: "Support Test",
              confidence: this.calculateBreakoutConfidence(
                currentPrice,
                support
              ),
              signal: "BUY",
              target: support * 1.05,
            }
          } else if (resistanceDistance < 0.02) {
            // Within 2% of resistance
            return {
              pattern: "Resistance Test",
              confidence: this.calculateBreakoutConfidence(
                resistance,
                currentPrice
              ),
              signal: "SELL",
              target: resistance * 0.95,
            }
          }

          return null
        }

        detectVolumeBreakout(data, features) {
          if (!features.volume) return null

          const volumeRatio = features.volume.volumeRatio
          if (volumeRatio > 2) {
            // 2x average volume
            return {
              pattern: "Volume Breakout",
              confidence: Math.min(100, volumeRatio * 25),
              signal: volumeRatio > 3 ? "BUY" : "NEUTRAL",
              target: data[data.length - 1].close * 1.03,
            }
          }

          return null
        }

        detectMomentumReversal(data, features) {
          if (!features.momentum) return null

          const rsi = features.momentum.rsi
          const momentumDivergence = features.momentum.momentumDivergence

          if (rsi < 30 && momentumDivergence > 0.1) {
            return {
              pattern: "Momentum Reversal (Bullish)",
              confidence: (30 - rsi) * 2,
              signal: "BUY",
              target: data[data.length - 1].close * 1.05,
            }
          } else if (rsi > 70 && momentumDivergence > 0.1) {
            return {
              pattern: "Momentum Reversal (Bearish)",
              confidence: (rsi - 70) * 2,
              signal: "SELL",
              target: data[data.length - 1].close * 0.95,
            }
          }

          return null
        }

        detectVolumeClimax(data, features) {
          if (!features.volume) return null

          const volumeSpikes = features.volume.volumeSpikes
          if (volumeSpikes > 3) {
            return {
              pattern: "Volume Climax",
              confidence: Math.min(100, volumeSpikes * 20),
              signal: "NEUTRAL",
              target: data[data.length - 1].close,
            }
          }

          return null
        }

        calculateBBPosition(data, bb) {
          if (!bb || !bb.upper || !bb.lower) return 0

          const currentPrice = data[data.length - 1].close
          const upper = bb.upper[bb.upper.length - 1]
          const lower = bb.lower[bb.lower.length - 1]

          return (currentPrice - lower) / (upper - lower)
        }

        calculateMAAlignment(data, indicators) {
          if (!indicators.ma20 || !indicators.ma50 || !indicators.ma200)
            return "neutral"

          const ma20 = indicators.ma20[indicators.ma20.length - 1]
          const ma50 = indicators.ma50[indicators.ma50.length - 1]
          const ma200 = indicators.ma200[indicators.ma200.length - 1]

          if (ma20 > ma50 && ma50 > ma200) return "bullish"
          if (ma20 < ma50 && ma50 < ma200) return "bearish"
          return "neutral"
        }
      }

      // Initialize AI pattern recognition
      const patternAI = new PatternRecognitionAI()

      // Update advanced analysis display
      function updateAdvancedAnalysis(analysis) {
        const advancedContainer = document.getElementById("advanced-analysis")
        if (!advancedContainer) return

        let html = "<h3>ü§ñ AI Pattern Recognition</h3>"

        // AI Patterns
        if (analysis.aiPatterns && analysis.aiPatterns.length > 0) {
          html += '<div class="pattern-section">'
          analysis.aiPatterns.slice(0, 5).forEach((pattern) => {
            const signalColor =
              pattern.signal === "BUY"
                ? "success"
                : pattern.signal === "SELL"
                ? "danger"
                : "warning"
            html += `
              <div class="pattern-item">
                <span class="pattern-name">${pattern.pattern}</span>
                <span class="pattern-confidence">${pattern.confidence.toFixed(
                  1
                )}%</span>
                <span class="pattern-signal badge-${signalColor}">${
              pattern.signal
            }</span>
                <span class="pattern-category">${pattern.category}</span>
              </div>
            `
          })
          html += "</div>"
        } else {
          html += "<p>No significant patterns detected</p>"
        }

        // Elliott Waves
        if (analysis.elliottWaves && analysis.elliottWaves.length > 0) {
          html += "<h3>üåä Elliott Wave Analysis</h3>"
          html += '<div class="elliott-section">'
          analysis.elliottWaves.slice(-5).forEach((wave) => {
            const direction = wave.direction > 0 ? "‚ÜóÔ∏è" : "‚ÜòÔ∏è"
            html += `
              <div class="wave-item">
                <span class="wave-number">Wave ${wave.wave}</span>
                <span class="wave-direction">${direction}</span>
                <span class="wave-length">${wave.length} periods</span>
                <span class="wave-range">$${wave.startPrice.toFixed(
                  2
                )} - $${wave.endPrice.toFixed(2)}</span>
              </div>
            `
          })
          html += "</div>"
        }

        // Harmonic Patterns
        if (analysis.harmonicPatterns && analysis.harmonicPatterns.length > 0) {
          html += "<h3>üéØ Harmonic Patterns</h3>"
          html += '<div class="harmonic-section">'
          analysis.harmonicPatterns.forEach((pattern) => {
            html += `
              <div class="harmonic-item">
                <span class="harmonic-name">${pattern.pattern}</span>
                <span class="harmonic-confidence">${pattern.confidence.toFixed(
                  1
                )}%</span>
              </div>
            `
          })
          html += "</div>"
        }

        // Volume Profile
        if (analysis.volumeProfile) {
          html += "<h3>ÔøΩÔøΩ Volume Profile</h3>"
          html += '<div class="volume-profile-section">'
          html += `<p><strong>POC:</strong> $${analysis.volumeProfile.poc.price.toFixed(
            2
          )}</p>`
          html += `<p><strong>Value Area:</strong> $${analysis.volumeProfile.valueArea[0].price.toFixed(
            2
          )} - $${analysis.volumeProfile.valueArea[
            analysis.volumeProfile.valueArea.length - 1
          ].price.toFixed(2)}</p>`
          html += "</div>"
        }

        // Order Flow
        if (analysis.orderFlow) {
          html += "<h3>üíπ Order Flow Analysis</h3>"
          html += '<div class="order-flow-section">'
          const pressure =
            analysis.orderFlow.buyingPressure >
            analysis.orderFlow.sellingPressure
              ? "Buying"
              : "Selling"
          html += `<p><strong>Pressure:</strong> ${pressure}</p>`
          html += `<p><strong>Volume Spikes:</strong> ${analysis.orderFlow.volumeSpikes.length}</p>`
          html += `<p><strong>Price Rejections:</strong> ${analysis.orderFlow.priceRejections.length}</p>`
          html += "</div>"
        }

        // Multi-timeframe Analysis
        if (analysis.multiTimeframeData) {
          html += "<h3>‚è∞ Multi-Timeframe Analysis</h3>"
          html += '<div class="timeframe-section">'
          Object.entries(analysis.multiTimeframeData).forEach(
            ([timeframe, data]) => {
              if (data && data.length > 0) {
                const trend = this.calculateTrend(data.map((d) => d.close))
                const trendIcon = trend > 0 ? "‚ÜóÔ∏è" : trend < 0 ? "‚ÜòÔ∏è" : "‚Üí"
                html += `
                <div class="timeframe-item">
                  <span class="timeframe-label">${timeframe}</span>
                  <span class="timeframe-trend">${trendIcon}</span>
                  <span class="timeframe-price">$${data[
                    data.length - 1
                  ].close.toFixed(2)}</span>
                </div>
              `
              }
            }
          )
          html += "</div>"
        }

        // Fundamental Data
        if (analysis.fundamentalData) {
          html += "<h3>üìà Fundamental Analysis</h3>"
          html += '<div class="fundamental-section">'
          const fd = analysis.fundamentalData
          html += `<p><strong>P/E Ratio:</strong> ${
            fd.peRatio ? fd.peRatio.toFixed(2) : "N/A"
          }</p>`
          html += `<p><strong>Market Cap:</strong> ${
            fd.marketCap ? this.formatMarketCap(fd.marketCap) : "N/A"
          }</p>`
          html += `<p><strong>Revenue Growth:</strong> ${
            fd.revenueGrowth ? (fd.revenueGrowth * 100).toFixed(1) + "%" : "N/A"
          }</p>`
          html += `<p><strong>Debt/Equity:</strong> ${
            fd.debtToEquity ? fd.debtToEquity.toFixed(2) : "N/A"
          }</p>`
          html += "</div>"
        }

        advancedContainer.innerHTML = html
      }

      // Enhanced chart update with advanced features
      function updateChart(data, indicators, fibonacci, aiPatterns) {
        const ctx = document.getElementById("price-chart")
        if (!ctx || !data || data.length === 0) return

        // Destroy existing chart
        if (window.priceChart) {
          window.priceChart.destroy()
        }

        const chartData = {
          labels: data.map((d) => d.date),
          datasets: [
            {
              label: "Price",
              data: data.map((d) => d.close),
              borderColor: "#8B0000",
              backgroundColor: "rgba(139, 0, 0, 0.1)",
              borderWidth: 2,
              fill: false,
            },
          ],
        }

        // Add moving averages
        if (indicators.ma20 && indicators.ma20.length > 0) {
          chartData.datasets.push({
            label: "MA20",
            data: indicators.ma20,
            borderColor: "#FFD700",
            backgroundColor: "transparent",
            borderWidth: 1,
            fill: false,
          })
        }

        if (indicators.ma50 && indicators.ma50.length > 0) {
          chartData.datasets.push({
            label: "MA50",
            data: indicators.ma50,
            borderColor: "#FFA500",
            backgroundColor: "transparent",
            borderWidth: 1,
            fill: false,
          })
        }

        // Add Bollinger Bands
        if (
          indicators.bb &&
          indicators.bb.upper &&
          indicators.bb.upper.length > 0
        ) {
          chartData.datasets.push({
            label: "BB Upper",
            data: indicators.bb.upper,
            borderColor: "rgba(0, 255, 0, 0.5)",
            backgroundColor: "transparent",
            borderWidth: 1,
            fill: false,
          })

          chartData.datasets.push({
            label: "BB Lower",
            data: indicators.bb.lower,
            borderColor: "rgba(255, 0, 0, 0.5)",
            backgroundColor: "transparent",
            borderWidth: 1,
            fill: false,
          })
        }

        const config = {
          type: "line",
          data: chartData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: "top",
                labels: {
                  color: "#FFFFFF",
                },
              },
              tooltip: {
                mode: "index",
                intersect: false,
                backgroundColor: "rgba(0, 0, 0, 0.8)",
                titleColor: "#FFFFFF",
                bodyColor: "#FFFFFF",
              },
            },
            scales: {
              x: {
                display: true,
                title: {
                  display: true,
                  text: "Date",
                  color: "#FFFFFF",
                },
                ticks: {
                  color: "#FFFFFF",
                  maxTicksLimit: 10,
                },
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
              },
              y: {
                display: true,
                title: {
                  display: true,
                  text: "Price ($)",
                  color: "#FFFFFF",
                },
                ticks: {
                  color: "#FFFFFF",
                },
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
              },
            },
            interaction: {
              mode: "nearest",
              axis: "x",
              intersect: false,
            },
          },
        }

        window.priceChart = new Chart(ctx, config)

        // Add Fibonacci levels annotation if available
        if (fibonacci) {
          addFibonacciAnnotations(fibonacci)
        }

        // Add pattern annotations if available
        if (aiPatterns && aiPatterns.length > 0) {
          addPatternAnnotations(aiPatterns)
        }
      }

      // Add Fibonacci retracement levels to chart
      function addFibonacciAnnotations(fibonacci) {
        const levels = fibonacci.levels
        const annotations = []

        Object.entries(levels).forEach(([ratio, price]) => {
          annotations.push({
            type: "line",
            mode: "horizontal",
            scaleID: "y",
            value: price,
            borderColor: "rgba(255, 215, 0, 0.7)",
            borderWidth: 1,
            borderDash: [5, 5],
            label: {
              content: `${ratio} ($${price.toFixed(2)})`,
              enabled: true,
              position: "left",
              backgroundColor: "rgba(255, 215, 0, 0.8)",
              color: "#000000",
            },
          })
        })

        if (window.priceChart) {
          window.priceChart.options.plugins.annotation = {
            annotations: annotations,
          }
          window.priceChart.update()
        }
      }

      // Add pattern annotations to chart
      function addPatternAnnotations(patterns) {
        const annotations = []

        patterns.slice(0, 3).forEach((pattern, index) => {
          if (pattern.points) {
            const points = pattern.points
            const x = Object.keys(points).length
            const y = Object.values(points)[Object.values(points).length - 1]

            annotations.push({
              type: "point",
              xValue: x,
              yValue: y,
              backgroundColor:
                pattern.signal === "BUY"
                  ? "rgba(0, 255, 0, 0.8)"
                  : "rgba(255, 0, 0, 0.8)",
              borderColor: pattern.signal === "BUY" ? "#00FF00" : "#FF0000",
              borderWidth: 2,
              radius: 6,
              label: {
                content: pattern.pattern,
                enabled: true,
                position: "top",
                backgroundColor: "rgba(0, 0, 0, 0.8)",
                color: "#FFFFFF",
              },
            })
          }
        })

        if (window.priceChart && annotations.length > 0) {
          if (!window.priceChart.options.plugins.annotation) {
            window.priceChart.options.plugins.annotation = { annotations: [] }
          }
          window.priceChart.options.plugins.annotation.annotations.push(
            ...annotations
          )
          window.priceChart.update()
        }
      }

      // Utility function to format market cap
      function formatMarketCap(marketCap) {
        if (marketCap >= 1e12) {
          return `$${(marketCap / 1e12).toFixed(2)}T`
        } else if (marketCap >= 1e9) {
          return `$${(marketCap / 1e9).toFixed(2)}B`
        } else if (marketCap >= 1e6) {
          return `$${(marketCap / 1e6).toFixed(2)}M`
        } else {
          return `$${marketCap.toFixed(0)}`
        }
      }

      // Calculate trend for multi-timeframe analysis
      function calculateTrend(data) {
        if (data.length < 2) return 0

        const x = Array.from({ length: data.length }, (_, i) => i)
        const y = data

        const n = data.length
        const sumX = x.reduce((a, b) => a + b, 0)
        const sumY = y.reduce((a, b) => a + b, 0)
        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0)
        const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0)

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)
        return slope
      }
    </script>
  </body>
</html>
